---
title: Constrained Bootstrapping Remote Secure Key Infrastructure (BRSKI)
abbrev: Constrained BRSKI
docname: draft-ietf-anima-constrained-voucher-13

stand_alone: true

ipr: trust200902
area: Internet
wg: anima Working Group
kw: Internet-Draft
cat: std
consensus: true
updates: 8366, 8995

pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:

- ins: M. Richardson
  name: Michael Richardson
  org: Sandelman Software Works
  email: mcr+ietf@sandelman.ca

- ins: P. van der Stok
  name: Peter van der Stok
  org: vanderstok consultancy
  email: stokcons@bbhmail.nl

- ins: P. Kampanakis
  name: Panos Kampanakis
  org: Cisco Systems
  email: pkampana@cisco.com

- ins: E. Dijk
  name: Esko Dijk
  org: IoTconsultancy.nl
  email: esko.dijk@iotconsultancy.nl

contributor:
  - name: Russ Housley
    email: housley@vigilsec.com

normative:
#  RFC2119:
  RFC8949:
  RFC7049:
  RFC4210:
  RFC7250:
  RFC8446:
  RFC6020:
  RFC6021:
  RFC6066:
  RFC6125:
  RFC7950:
  RFC5652:
  RFC4193:
  RFC8366:
  RFC3688:
  RFC8610:
  RFC8995:
  I-D.ietf-cose-rfc8152bis-struct:
  I-D.ietf-cose-rfc8152bis-algs:
  RFC9031: minimal-security
#  I-D.ietf-core-object-security:
#  I-D.ietf-ace-cbor-web-token:
  I-D.ietf-ace-coap-est:
  I-D.ietf-cose-x509:
  ieee802-1AR:
    target: "http://standards.ieee.org/findstds/standard/802.1AR-2009.html"
    title: "IEEE 802.1AR Secure Device Identifier"
    author:
      ins: "IEEE Standard"
    date: 2009

informative:
  RFC7228:
  RFC8340: yang-tree
  I-D.kuehlewind-update-tag:
  COSE-registry:
    title: "CBOR Object Signing and Encryption (COSE) registry"
    target: "https://www.iana.org/assignments/cose/cose.xhtml"
    author:
      ins: "IANA"
    date: 2017
  I-D.richardson-anima-masa-considerations:
  RFC6690:
  RFC7030:
  I-D.ietf-core-sid:
  I-D.ietf-core-yang-cbor:

--- abstract

This document defines a protocol to securely assign a Pledge to an
owner and to enroll it into the owner's network.
The protocol uses an artifact that is signed by the Pledge's manufacturer.
This artifact is known as a "voucher".

This document builds upon the work in [RFC8366] and [BRSKI], but defines an encoding of
the voucher in CBOR rather than JSON, and enables the Pledge to perform its transactions using CoAP rather than HTTPS.

The use of Raw Public Keys instead of X.509 certificates for security operations is also explained.

--- middle

# Introduction

Secure enrollment of new nodes into constrained networks with constrained nodes presents unique challenges.
As explained in {{RFC7228}}, the networks are challenged and the nodes are constrained by energy, memory space, and code size.

The Bootstrapping Remote Secure Key Infrastructure (BRSKI) protocol described in {{RFC8995}}
provides a solution for secure zero-touch (automated) bootstrap of new (unconfigured) devices.
In it, new devices, such as IoT devices, are called "pledges", and equipped with a factory-installed Initial Device Identifier (IDevID) (see {{ieee802-1AR}}), they are enrolled into a network.

The BRSKI solution described in {{RFC8995}} was designed to be modular, and this document describes a version scaled to the constraints of IoT deployments.

Therefore, this document defines a constrained version of the voucher artifact (described in {{RFC8366}}), along with a constrained version of BRSKI.
This constrained-BRSKI protocol makes use of the constrained CoAP-based version of EST (EST-coaps from {{I-D.ietf-ace-coap-est}}) rather than the EST over HTTPS {{RFC7030}}.

In BRSKI, the the {{RFC8366}} voucher is by default serialized to JSON with a signature in CMS {{RFC5652}}.
This document defines a new voucher serialization to CBOR {{RFC8949}} with a signature in COSE {{I-D.ietf-cose-rfc8152bis-struct}}.

This COSE-signed CBOR-encoded voucher is transported using secured CoAP and HTTPS.

The CoAP connection (between Pledge and Registrar) is to be protected by either OSCORE+EDHOC or DTLS (CoAPS).
The HTTP connection (between Registrar and MASA) is to be protected using TLS (HTTPS).

This document specifies a constrained voucher-request artifact based on {{Section 3 of RFC8995}}, and
voucher(-request) transport over CoAP based on {{Section 3 of RFC8995}} and on {{I-D.ietf-ace-coap-est}}.

 The table of VK values presented here MUST be considered normative rather than the output of the pyang tool.

There is additional work when the voucher is integrated into the key-exchange, described in {{!I-D.selander-ace-ake-authz}}.
This work is not in scope for this document.

# Terminology          {#Terminology}

The following terms are defined in {{RFC8366}}, and are used identically as in that document:
artifact, domain, imprint, Join Registrar/Coordinator (JRC), Manufacturer Authorized Signing Authority
(MASA), Pledge, Registrar, Trust of First Use (TOFU), and Voucher.

The following terms from {{RFC8995}} are used identically as in that document:
Domain CA, enrollment, IDevID, Join Proxy, LDevID, manufacturer, nonced, nonceless, PKIX.

The term Pledge Voucher Request, or acronym PVR, is introduced to refer to the voucher request between the pledge and the Registrar.

The term Registrar Voucher Request, or acronym RVR, is introduced to refer to the voucher request between the Registrar and the MASA.

# Requirements Language {#reqlang}

{::boilerplate bcp14}

# Overview of Protocol {#survey}

{{RFC8366}} provides for vouchers that assert proximity, that authenticate the Registrar and that can offer varying levels of anti-replay protection.

The proximity proof provided for in {{RFC8366}}, is an assertion that the Pledge and the Registrar are believed to be in close together, from a network topology point of view.
Like in {{RFC8995}}, proximity shown by making TLS connections between the Pledge and Registrar using IPv6 Link-Local addresses.

The TLS connection is used to make a Voucher Request.
This request is verified by the an agent of the Pledge's manufacturer, which then issues a voucher.
The voucher provides an authorization statement from the manufacturer indicating that the Registrar is the intended owner of the device.
The voucher refers to the Registrar through pinning of the Registrar's identity.

This document does not make any extensions to the semantic meaning of vouchers, only the encoding has been changed to optimize for constrained devices and networks.
The two main parts of the BRSKI protocol are named separately in this document: BRSKI-EST for the protocol between Pledge and Registrar, and BRSKI-MASA for the
protocol between the Registrar and the MASA.

Time-based vouchers are supported in this definition, but given that constrained devices are extremely unlikely to have accurate time, their use will be uncommon.
Most Pledges using constrained vouchers will be online during enrollment and will use live nonces to provide anti-replay protection rather than expiry times.

{{RFC8366}} defines the voucher artifact, while the Voucher Request artifact was defined in {{RFC8995}}.
This document defines both a constrained voucher and a constrained voucher-request.
They are presented in the order "voucher-request", followed by a "voucher" response as this is
the order that they occur in the protocol.

The constrained voucher request MUST be signed by the Pledge.
It signs using the private key associated with its IDevID X.509 certificate, or if an IDevID is not available, then the private key associated with its manufacturer-installed raw public key (RPK).
{{rpk-considerations}} provides additional details on PKIX-less operations.

The constrained voucher MUST be signed by the MASA.

For the constrained voucher request this document defines two distinct methods for the Pledge to identify the Registrar: using either the Registrar's X.509 certificate, or using a raw public key (RPK) of the Registrar.

For the constrained voucher also these two methods are supported to indicate (pin) a trusted domain identity: using either a pinned domain X.509 certificate, or a pinned raw public key (RPK).

The BRSKI architectures mandates that the MASA be aware of the capabilities of the pledge.
This is not a hardship as the pledges are constructed by a manufacturer who also arranges for the MASA to be aware of the inventory of devices.

The MASA therefore knows if the pledge supports PKIX operations, PKIX format certificates, or if the pledge is limited to Raw Public Keys (RPK).
Based upon this, the MASA can select which attributes to use in the voucher for certain operations, like the pinning of the Registrar identity.
This is described in more detail in {{yang-voucher}}, {{pinning}} and {{pinned-with-rpk}} (for RPK specifically).

# Updates to RFC8366 and RFC8995

This section details the ways in which this document Updates.
The terminology for Updates is taken from {{I-D.kuehlewind-update-tag}}.

This document Updates {{RFC8366}}. It Extends {{RFC8366}} by creating a new serialization format.

This document Updates {{RFC8995}}. It Amends {{RFC8995}} by clarifying how pinning is done, and ???.

# BRSKI-EST Protocol {#brski-est}

This section describes the constrained BRSKI extensions to EST-coaps {{I-D.ietf-ace-coap-est}} to transport the voucher between Registrar and Pledge (optionally via a Join Proxy) over CoAP.
The extensions are targeting low-resource networks with small packets.

The constrained BRSKI-EST protocol described in this section is between the Pledge and the Registrar only.

## Registrar and the Server Name Indicator (SNI)

A DTLS connection is established between the pledge and the Registrar.
As described in {{Section 5.1 of RFC8995}} the pledge establishes a TLS connection to the Registrar.
This occurs via a variety of Join Proxy mechanisms described in {{joinproxy}}.
Regardless of the mechanism, the DTLS connection should operate identically.

This issue affects {{RFC8995}} as well, and is reported in errata: https://www.rfc-editor.org/errata/eid6648

As the Registrar is discovered by IP address, and connected via the Join proxy, the name of the Registrar is not known to the Pledge.
The Pledge will not know what the hostname for the Registrar is, so the pledge can not do RFC6125 DNS-ID validation on the Registrar's certificate.
That is the purpose of the RFC8366 voucher.

As the Pledge does not know the name of the Registrar, the Pledge cannot put any reasonable value into the {{RFC6066}} Server Name Indicator (SNI).
The pledge SHOULD omit the SNI extension as per {{Section 9.2 of RFC8446}}.

In some cases, particularly when debugging and doing interoperability testing, a Pledge may be  given the hostname of a particular Registrar to connect to.
Such a bypass of the discovery process may result in the Pledge taking a different path to DTLS connection, and may result in the SNI being inserted by a library.
The Registrar MUST ignore any SNI seen.

A primary motivation for making the SNI ubiquitous in the public web is because it allows for multi-tenant hosting of HTTPS sites on a single (scarce) IPv4 address.
This consideration does not apply to the Registrar because:

* it uses DTLS and CoAP, not HTTPS

* it uses IPv6, often {{RFC4193}} Unique Local Address, which are plentiful

* the port number number is discovered, so multiple tenants can be accomodate via unique port numbers.

As per {{Section 3.6.1 of RFC7030}}, the Registrar certificate MUST have the Extended Key Usage (EKU) id-kp-cmcRA.
This certificate is also used as a TLS Server Certificate, so it must also have the EKU id-kp-serverAuth.

## TLS Client Certificates: IDevID authentication

As described in {{Section 5.1 of RFC8995}}, the Pledge makes a connection to the Registrar using  TLS Client Certificate for authentication.

Subsequently the pledge will send a Pledge Voucher Request (PVR).

As explained below in {{registrar-identity}}, the "x5bag" may be used in the RVR to communicate identity of the Registrar to MASA.
The Pledge SHOULD NOT use the x5bag attribute in this way in the PVR.
A Registrar that processes a PVR with an x5bag attribute MUST ignore it, and MUST use only the TLS Client Certificate extension for authentication of the Pledge.

A situation where the pledge MAY use the x5bag is for communications of certificate chains to the MASA.
This would arise in some vendor specific situations involving outsourcing of MASA functionality, or rekey of IDevID certification authority.

## Discovery, URIs and Content Formats

To keep the protocol messages small the EST-coaps and constrained-BRSKI URIs are shorter than the respective EST and BRSKI URIs.

The EST-coaps server URIs differ from the EST URIs by replacing the scheme https by coaps and by specifying shorter resource path names. Below are some examples;
the first two using a discovered short path name and the last one using the well-known URI of EST which requires no discovery.

~~~~
  coaps://server.example.com/est/<short-name>
  coaps://server.example.com/e/<short-name>
  coaps://server.example.com/.well-known/est/<short-name>
~~~~

Similarly the constrained BRSKI server URIs differ from the BRSKI URIs by replacing the scheme https by coaps and by specifying shorter resource path names. Below are some examples;
the first two using a discovered short path name and the last one using the well-known URI prefix which requires no discovery.
This is the same "/.well-known/brski" prefix as defined in {{Section 5 of RFC8995}}.

~~~~
  coaps://server.example.com/brski/<short-name>
  coaps://server.example.com/b/<short-name>
  coaps://server.example.com/.well-known/brski/<short-name>
~~~~

Figure 5 in {{Section 3.2.2 of RFC7030}} enumerates the operations supported by EST, for which Table 1 in {{Section 5.1 of I-D.ietf-ace-coap-est}} enumerates the corresponding
EST-coaps short path names. Similarly, {{est-uri}} provides the mapping from the supported BRSKI extension URI paths to the constrained-BRSKI URI paths.

| BRSKI resource | constrained-BRSKI resource |
| /requestvoucher| /rv |
| /voucher_status | /vs |
| /enrollstatus | /es  |
{: #est-uri title='BRSKI URI paths mapping to constrained BRSKI URI paths'}

Note that /requestvoucher indicated above occurs between the Pledge and Registrar (in scope of the BRSKI-EST protocol), but it also occurs between Registrar and MASA. However,
as described in {{brski-est}}, this section and above table addresses only the BRSKI-EST protocol.

Pledges that wish to discover the available BRSKI bootstrap options/formats, or reduce the size of the CoAP headers by eliminating the "/.well-known/brski" path, can do a discovery operation using {{RFC6690}} Section 4 by sending a discovery query to the Registrar.

For example, if the Registrar supports a short BRSKI URL (/b) and supports the voucher format "application/voucher-cose+cbor" (TBD3), and status reporting in both CBOR and JSON formats:

~~~~
  REQ: GET /.well-known/core?rt=brski*

  RES: 2.05 Content
  Content-Format: 40
  Payload:
  </b>;rt=brski,
  </b/rv>;rt=brski.rv;ct=TBD3,
  </b/vs>;rt=brski.vs;ct="50 60",
  </b/es>;rt=brski.es;ct="50 60"
~~~~

The Registrar is under no obligation to provide shorter URLs, and MAY respond to this query with only the "/.well-known/brski/\<short-name\>" end points for the short names as defined in {{est-uri}}.

Registrars that have implemented shorter URLs MUST also respond in equivalent ways to the corresponding "/.well-known/brski/\<short-name\>" URLs, and MUST NOT distinguish between them.
In particular, a Pledge MAY use the longer and shorter URLs in any combination.

When responding to a discovery request for BRSKI resources, the server MAY in addition return
the full resource paths and the content types which are supported at those end-points as shown in above example.
This is useful when multiple content types are specified for a particular resource on the server.
The server responds with only the root path for the BRSKI resource (rt=brski, resource /b in above example) and no others in case the client queries for only rt=brski type resources.
(So, a query for rt=brski, without the wildcard character.)

Without discovery, a longer well-known URL can only be used, such as:

~~~~
   REQ: GET /.well-known/brski/rv
~~~~

while with discovery of shorter URLs, a request such as:

~~~~
   REQ: GET /b/rv
~~~~

is possible.

The return of multiple content-types in the "ct" attribute allows the Pledge to choose the most appropriate one.
Note that Content-Format TBD3 ("application/voucher-cose+cbor") is defined in this document.

Content-Format TBD3 MUST be supported by the Registrar for the /rv resource.
If the "ct" attribute is not indicated for the /rv resource in the link format description, this implies that at least TBD3 is supported.

Note that this specification allows for voucher-cose+cbor format requests and vouchers to be transmitted over HTTPS, as well as for voucher-cms+json and other formats TBD over CoAP.
The burden for this flexibility is places upon the Registrar.
The pledge is expected to support a single format only.

The Pledge and MASA need to support one or more formats (at least TBD3) for the voucher and for the voucher request.
The MASA needs to support all formats that the Pledge, produced by that manufacturer, supports.

### RFC8995 Telemetry Returns

{{RFC8995}} defines two telemetry returns from the Pledge which are sent to the Registrar.
These are the BRSKI Status Telemetry {{RFC8995, Section 5.7}} and the Enrollment Status Telemetry {{RFC8995, Section 5.9.4}}.
These are two POST operations made the by Pledge at two key steps in the process.

{{RFC8995}} defines the content of these POST operations in CDDL, which are serialized as JSON.
This document extends the list of acceptable formats to CBOR as well as JSON, using the rules from {{RFC8610}}.

The existing JSON format is described as CoAP Content-Format 50 ("application/json"), and it MAY be supported.
The new CBOR format is described using CoAP Content-Format 60 ("application/cbor") MUST be supported by the Registrar for both the /vs and /es resources.

## Join Proxy options {#joinproxy}
TBD; reference other documents.

## Extensions to BRSKI {#brski-extensions}

### Discovery {#brski-extensions-discovery}

The Pledge discovers an IP address and port number that connects to the Registrar (possibly via a Join Proxy), and it establishes a DTLS connection.

No further discovery of hosts or port numbers is required, but a pledge that can do more than one kind of enrollment (future work offers protocols other than {{I-D.ietf-ace-coap-est}}), then a pledge may need to use CoAP Discovery to determine what other protocols are available.

A Pledge that only supports the EST-coaps enrollment method SHOULD NOT use discovery for BRSKI resources.
It is more efficient to just try the supported enrollment method via the well-known BRSKI/EST-coaps resources.
This also avoids the Pledge doing any CoRE Link Format parsing, which is specified in {{I-D.ietf-ace-coap-est, Section 4.1}}.

In order to support this, the Registrar MUST support all of the EST resources at their default ".well-known" locations (on the port number discovered)
as well as any server-specific shorter form that might also be supported.

However, when discovery is being done by the Pledge, it is possible for the Registrar to return references to resources which are on different port numbers.
The Registrar SHOULD NOT use different ports numbers by default, because a Pledge that is connected via a Join Proxy can only access a single UDP port.
A Registrar configured to never use Join Proxies MAY be configured to use multiple port numbers.
Therefore a Registrar MUST host all discoverable BRSKI resources on the same (UDP) server port that the Pledge's DTLS connection is using.
In addition to avoiding the problem of being unable to connect to other ports, using the same UDP server port allows the Pledge to continue to use the same DTLS connection
which is more efficient.

### CoAP responses {#brski-coap-responses}

{{RFC8995, Section 5}} defines a number of HTTP response codes that the Registrar is to return when certain conditions occur.

The 401, 403, 404, 406 and 415 response codes map directly to CoAP codes 4.01, 4.03, 4.04, 4.06 and 4.15.

The 202 Retry process which occurs in the voucher request, is to be handled in the same way as {{Section 5.7 of I-D.ietf-ace-coap-est}} process for Delayed Responses.


## Extensions to EST-coaps {#brski-est-extensions}

This document extends {{I-D.ietf-ace-coap-est}}, and it inherits the functions described in that document:
specifically, the mandatory Simple (Re-)Enrollment (/sen and /sren) and Certification Authority certificates request (/crts).
Support for CSR Attributes Request (/att) and server-side key generation (/skg, /skc) remains optional for the EST server.

Collecting both {{RFC8995}} and {{RFC7030}}, {{I-D.ietf-ace-coap-est}} and this document results in the following shorter forms of URI paths
for the commonly used resources:

<!-- Table order is currently the order in which typically the resources are used by Pledge. Change if we want to -->
       +------------------+-------------------+----------------+
       | EST + BRSKI      | Constrained-BRSKI | Well-known URI +
       |                  |                   |   namespace    +
       +------------------+-------------------+----------------+
       | /requestvoucher  | /rv               | brski          +
       | /voucher_status  | /vs               | brski          +
       | /csrattrs        | /att              | est            +
       | /simpleenroll    | /sen              | est            +
       | /cacerts         | /crts             | est            +
       | /enrollstatus    | /es               | brski          +
       | /simplereenroll  | /sren             | est            +
       +------------------+-------------------+----------------+


### Pledge Extensions {#brski-est-extensions-pledge}

This section defines extensions to the BRSKI Pledge, which are applicable during the BRSKI bootstrap procedure.
A Pledge that already is DTLS-connected to either a Join Proxy or Registrar, and which only supports the EST-coaps enrollment method, SHOULD NOT use discovery for EST-coaps resources.
This is because it is more efficient to just try its supported enrollment method (e.g. /sen) via the well-known EST resource on the current DTLS connection.
This avoids an additional round-trip of packets and avoids the Pledge having to unnecessarily implement CoRE Link Format parsing.

A constrained Pledge SHOULD NOT perform the optional EST "CSR attributes request" (/att) to minimize network traffic and reduce code size.

When creating the CSR, the Pledge selects which attributes to include. One or more Subject Distinguished Name fields MUST be included.
If the Pledge has no specific information on what attributes/fields are desired in the CSR, it MUST use the Subject Distinguished Name fields from its IDevID unmodified.
The Pledge can receive such information via the voucher (encoded in a vendor-specific way) or some other, out-of-band means.

A constrained Pledge MAY use the following optimized EST-coaps procedure to minimize both network traffic and code size:

1. if the voucher, that validates the current Registrar, contains a single pinned domain CA certificate, the Pledge provisionally considers this certificate as the EST trust anchor, in other words,
it provisionally accepts this CA certificate as if it were the result of "CA certificates request" (/crts) to the Registrar.

2. Using this CA certificate as trust anchor it proceeds with EST simple enrollment (/sen) to obtain its provisionally trusted LDevID.

3. If the Pledge validates that the trust anchor CA was used to sign its LDevID, the Pledge accepts the pinned domain CA certificate as the legitimate trust anchor CA for the Registrar's domain and accepts the associated LDevID.

4. If the trust anchor CA was NOT used to sign its LDevID, the Pledge MUST perform an actual "CA certificates request" (/crts) to the EST server to obtain the EST CA trust anchor(s) since these differ from the (temporary) pinned domain CA.

5. When doing this /crts request, the Pledge MAY use a CoAP Accept Option with value TBD287 ("application/pkix-cert") to limit the number of returned EST CA trust anchors to only one.
A constrained Pledge MAY support only this format in a /crts response, per {{Section 5.3 of I-D.ietf-ace-coap-est}}.

7. If the Pledge cannot obtain the single CA certificate or the finally validated CA certificate cannot be chained to the LDevID, then the Pledge MUST abort the enrollment process and report the error using the enrollment status telemetry (/es).


### EST-client Extensions {#brski-est-extensions-estclient}

This section defines extensions to EST-coaps clients, used after the BRSKI bootstrap procedure is completed.
(Note that such client is not called "Pledge" in this section, since it is already enrolled into the domain.)
A constrained EST-coaps client MAY support only the Content-Format TBD287 ("application/pkix-cert") in a /crts response, per {{Section 5.3 of I-D.ietf-ace-coap-est}}.

In this case, it can only store one trust anchor of the domain. Although this is not an issue in case the domain trust anchor remains stable, special consideration is
needed for cases where the domain trust anchor can change over time.
The mechanism described in {{RFC4210, Section 4.4}} allows for a new CA to sign the old CA, so even during rollover of trust anchors, it is possible to have only a single trust anchor.
Such a change may happen during EST re-enrollment: typically, a change of domain CA requires all devices
operating under the old domain CA to acquire a new LDevID issued by the new domain CA. A client's re-enrollment may be triggered by various events, such as imminent expiry of its LDevID.
How the re-enrollment is explicitly triggered on the client by a domain entity, such as a commissioner or a Registrar, is out of scope of this specification.

For re-enrollment, the constrained EST-coaps client MUST support the following EST-coaps procedure, where optional re-enrollment to a new domain is under control of the Registrar:

1. The client connects with DTLS to the Registrar, and authenticates with its present domain certificate (LDevID) as usual. The Registrar authenticates itself with its domain certificate that
is trusted by the client, i.e. it chains to the single trust anchor that the client has stored. This is the "old" trust anchor, the one that will be eventually replaced in case the Registrar
decides to re-enroll the client into a new domain.

2. The client performs the simple re-enrollment request (/sren) and upon success it obtains a new LDevID.

3. The client verifies the new LDevID against its (single) existing domain trust anchor. If it chains successfully, this means the trust anchor did not change and the client MAY skip retrieving the current CA certificate using the "CA certificates request" (/crts). If it does not chain successfully, this means the trust anchor was changed/updated and the client then MUST retrieve the new domain trust anchor using the "CA certificates request" (/crts).

4. If the client retrieved a new trust anchor in step 3, then it MUST verify that the new trust anchor chains with the new LDevID it obtained in step 2. If it chains successfully, the client stores both, accepts the new LDevID and stops using it prior LDevID. If it does not chain successfully, the client MUST NOT update its LDevID, it MUST NOT update its (single) domain trust anchor, and the client MUST abort the enrollment process and report the error to the Registrar using enrollment status telemetry (/es).


### Registrar Extensions {#brski-est-extensions-registrar}

A Registrar SHOULD host any discoverable EST-coaps resources on the same (UDP) server port that the Pledge's DTLS initial connection is using.
This avoids the Pledge having to reconnect using DTLS, in order to proceed with EST enrollment after the BRSKI bootstrap.
[TBD EDNOTE: a Registrar that does host EST resources on another port won't be able to onboard Pledges that skip the discovery, so not interoperable. Should we fix this?]

The Content-Format 50 (application/json) MUST be supported and 60 (application/cbor) MUST be supported by the Registrar for the /vs and /es resources.

Content-Format TBD3 MUST be supported by the Registrar for the /rv resource.

When a Registrar receives a "CA certificates request" (/crts) request with a CoAP Accept Option with value TBD287 ("application/pkix-cert") it SHOULD return only the
single CA certificate that is the envisioned or actual authority for the current, authenticated Pledge making the request.

If the Pledge included in its request an Accept Option for only the TBD287 ("application/pkix-cert") Content Format, but the domain has been configured to operate with multiple CA trust anchors only, then the Registrar returns a 4.06 Not Acceptable error to signal that the Pledge needs to use the Content Format 281 ("application/pkcs7-mime; smime-type=certs-only") to retrieve all the certificates.

If the current authenticated client is an EST-coaps client that was already enrolled in the domain, and the Registrar is configured to assign this client to a new domain CA trust anchor during the next EST re-enrollment procedure, then the Registrar MUST respond with the new domain CA certificate in case the client performs the "CA Certificates request" (/crts) with an Accept Option for TBD287 only. This signals the client that a new domain is assigned to it. The client follows the procedure as defined in {{brski-est-extensions-estclient}}.

# BRSKI-MASA Protocol {#brski-masa}
This section describes extensions to and clarifications of the BRSKI-MASA protocol between Registrar and MASA.

## Protocol and Formats {#brski-masa-protocol-format}

{{Section 5.4 of RFC8995}} describes a connection between the Registrar and the MASA as being a normal TLS connection using HTTPS.
This document does not change that. The Registrar MAY use the new format "application/voucher-cose+cbor" in its voucher request to MASA, or the existing BRSKI
format "application/voucher-cms+json" defined by {{RFC8995}}.

The MASA only needs to support formats for which there are Pledges that use that format.

The Registrar MUST use the same format for the RVR as the Pledge used for its PVR.

The Registrar indicates the voucher format it wants to receive from MASA using the HTTP Accept header.
This format MUST be the same as the format of the PVR, so that the Pledge can parse it.

At the moment of writing the creation of coaps based MASAs is deemed unrealistic.
The use of CoAP for the BRSKI-MASA connection can be the subject of another document.
Some consideration was made to specify CoAP support for consistency, but:

* the Registrar is not expected to be so constrained that it cannot support HTTPS client connections.

* the technology and experience to build Internet-scale HTTPS responders (which the MASA is) is common, while the experience doing the same for CoAP is much less common.

* in many Enterprise networks, outgoing UDP connections are often treated as suspicious, and there seems to be no advantage to using CoAP in that environment.

* a Registrar is likely to provide onboarding services to both constrained and non-constrained devices.  Such a Registrar would need to speak HTTPS anyway.

* similarly, a manufacturer is likely to offer both constrained and non-constrained devices, so there may in practice be no situation in which the MASA could be CoAP-only.  Additionally, as the MASA is intended to be a function that can easily be oursourced to a third-party service provider, reducing the complexity would also seem to reduce the cost of that function.

## Registrar Voucher Request {#brski-masa-rvr}

If the PVR contains a proximity assertion, the Registrar MUST propagate this assertion into the RVR by including the "assertion" field with the value "proximity".
This conforms to the example in {{Section 3.3 of RFC8995}} of carrying the assertion forward.

## MASA and the Server Name Indicator (SNI)

A TLS/HTTPS connection is established between the Registrar and MASA.

{{Section 5.4 of RFC8995}} explains this process, and there are no externally visible changes.
A MASA that supports the unconstrained voucher formats should be able to support constrained vouchers requests equally well.

There is no requirement that a single MASA be used for both constrained and unconstrained voucher requests: the choice of MASA is determined by the id-mod-MASAURLExnn2016 extension contained in the IDevID.

The Registrar MUST do {{RFC6125}} DNS-ID checks on the contents of the certificate provided by the MASA.

In constrast to the Pledge/Registrar situation, the Registrar always knows the name of the MASA, and MUST always include an {{RFC6066}} Server Name Indicator.
The SNI is optional in TLS1.2, but common.
The SNI it considered mandatory with TLS1.3, so this requirement is not unusual.

The presence of the SNI is need by the MASA in order for the MASA to host multiple tenants (for different customers).

The Registrar SHOULD use a TLS Client Certificate to authenticate to the MASA.
If the certificate that the Registrar uses is marked as a cmcRA certificate, via Extended Key Usage, then it MUST also have the id-kp-clientAuth EKU attribute set.

### Registrar Certificate Requiurement

In summary for typical Registrar use, where a single Registrar certificate is used, then the certificate MUST have EKU of: id-kp-cmcRA, id-kp-serverAuth, id-kp-clientAuth.

<!-- ******************************************************************** -->

# Pinning in Voucher Artifacts {#pinning}

The voucher is a statement by the MASA for use by the Pledge that provide the identity of the Pledge's owner.
This section describes how the owner's identity is determined and how it is encoded within the voucher.

## Registrar Identity Selection and Encoding {#registrar-identity}

{{Section 5.5 of RFC8995}} describes BRSKI policies for selection of the owner identity. It indicates some of the flexibility that is possible for the Registrar.

The recommendation made there is for the Registrar to include only certificates in the voucher request (CMS) signing structure that participate in the certificate chain that is to be pinned.

The MASA is expected to evaluate the certificates included by the Registrar in its voucher request, forming them into a chain with the Registrar's (signing) identity on one end. Then, it pins a certificate selected from the chain.
For instance, for a domain with a two-level certification authority (see {{fig-twoca}}), where the voucher-request has been signed by "Registrar", its signing structure includes two additional CA certificates:

~~~~
{::include two-ca-chain.txt}
~~~~
{: #fig-twoca title='Two-Level CA PKI'}

When the Registrar is using a COSE-signed constrained voucher request towards MASA, instead of a regular CMS-signed voucher request, the COSE_Sign1 object contains a protected and an unprotected header.
The Registrar MUST place all the certificates needed to validate the signature chain from the Registrar on the RVR in an "x5bag" attribute in the unprotected header {{I-D.ietf-cose-x509}}.

The "x5bag" attribute is very important as it provides the required signals from the Registrar to control what identity is pinned in the resulting voucher.
This is explained in the next section.

## MASA Pinning Policy {#masa-pinning-policy}

The MASA, having assembled and verified the chain in the signing structure of the voucher request, will now need to select a certificate to pin.
(For the case that only the Registrar's End-Entity certificate is included, only this certificate can be selected and this section does not apply.)
The BRSKI policy for pinning by the MASA as described in {{Section 5.5.2 of RFC8995}} leaves much flexibility to the manufacturer.

The present document adds the following rules to the MASA pinning policy to reduce the network load:

1. for a voucher containing a nonce, it SHOULD select the most specific (lowest-level) CA certificate in the chain.
2. for a nonceless voucher, it SHOULD select the least-specific (highest-level) CA certificate in the chain that is allowed under the MASA's policy for this specific domain.

The rationale for 1. is that in case of a voucher with nonce, the voucher is valid only in scope of the present DTLS connection between Pledge and Registrar anyway, so it would have no
benefit to pin a higher-level CA. By pinning the most specific CA the constrained Pledge can validate its DTLS connection using less crypto operations. The
rationale for pinning a CA instead of the Registrar's End-Entity certificate directly is the following benefit on constrained networks: the pinned certificate in the voucher
can in common cases be re-used as a Domain CA trust anchor during the EST enrollment and during the operational phase that follows after EST enrollment, as explained in {{brski-est-extensions-pledge}}.

The rationale for 2. follows from the flexible BRSKI trust model for, and purpose of, nonceless vouchers (Sections 5.5.* and 7.4.1 of {{RFC8995}}).

Using the previous example of a domain with a two-level certification authority, the most specific CA ("Sub-CA") is the identity that is pinned by MASA in a nonced voucher.
A Registrar that wished to have only the Registrar's End-Entity certificate pinned would omit the "domain CA" and "Sub-CA" certificates from the voucher-request.

In case of a nonceless voucher, the MASA would depending on trust level pin only "Registrar" certificate (low trust in customer), or the "Sub-CA" certificate (in case of
medium trust, implying that any Registrar of that sub-domain is acceptable), or even the "domain CA" certificate (in case of high trust in the customer, and possibly a pre-agreed need of the
customer to obtain flexible long-lived vouchers).

## Pinning of Raw Public Keys {#pinned-with-rpk}

Specifically for constrained use cases, the pinning of the raw public key (RPK) of the Registrar is also supported in the constrained voucher, instead of an X.509 certificate.
If an RPK is pinned it MUST be the RPK of the Registrar.

When the Pledge is known by MASA to support RPK but not X.509 certificates, the voucher produced by the MASA pins the RPK of the Registrar in either the "pinned-domain-pubk"
or "pinned-domain-pubk-sha256" field of a voucher.
This is described in more detail in {{yang-voucher}}. A Pledge that does not support X.509 certificates cannot use EST to enroll; it has to use
another method for enrollment without certificates and the Registrar has to support this method also.
It is possible that the Pledge will not enroll, but instead only a network join operation will occur, such as described in {{RFC9031}}.
How the Pledge discovers this method and details of the enrollment method are out of scope of this document.

When the Pledge is known by MASA to support PKIX format certificates, the "pinned-domain-cert" field present in a voucher typically pins a domain certificate.
That can be either the End-Entity certificate of the Registrar, or the certificate of a domain CA of the Registrar's domain as specified in {{masa-pinning-policy}}.
However, if the Pledge is known to also support RPK pinning and the MASA intends to identify the Registrar in the voucher (not the CA), then MASA MUST pin the RPK (RPK3 in {{fig-pinning}}) of the Registrar instead of the Registrar's End-Entity certificate to save space in the voucher.

~~~~
{::include pinning-options.txt}
~~~~
{: #fig-pinning title='Raw Public Key pinning'}

<!-- ******************************************************************** -->

# Artifacts

This section describes for both the voucher request and
the voucher first the abstract (tree) definition as explained
in {{-yang-tree}}.  This provides a high-level
view of the contents of each artifact.

The yang voucher and voucher-request are encoded following the cbor rules defined {{RFC7049}}. An JSON array is encoded as a a CBOR array, and a JSON item is encoded as a CBOR map. In addition the cbor json identifiers that serve as map keys are converted to numbers, called Voucher Keys (VK) as also proposed in {{I-D.ietf-core-sid}}.

## Voucher Request artifact

### Tree Diagram

The following diagram is largely a duplicate of the contents of {{RFC8366}},
with the addition of the fields proximity-registrar-pubk, proximity-registrar-pubk-sha256,
proximity-registrar-cert, and prior-signed-voucher-request.

prior-signed-voucher-request is only used between the Registrar and the MASA.
proximity-registrar-pubk or proximity-registrar-pubk-sha256 optionally replaces proximity-registrar-cert
for the most constrained cases where RPK is used by the Pledge.

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained-tree.txt END

Table 1 mapping from yang type to CBOR type for voucher request.

The CBOR text string of the dates MUST conform to the specification of section 3 in {{RFC6021}}.

### VK values

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained-sid.txt END

Table 2 mapping from yang identifier to Voucher Key (VK) for voucher-request

### YANG Module {#yang-voucher-request}

In the constrained-voucher-request YANG module, the voucher is "augmented" within the "used" grouping statement such that one continuous set of VK values is generated for the constrained-voucher-request module name, all voucher attributes, and the constrained-voucher-request attributes. Two attributes of the voucher are "refined" to be optional.

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained@DATE.yang END

### Example voucher request artifact {#example2}

Below is a CBOR serialization of an example constrained voucher request from a Pledge to a Registrar, shown in CBOR diagnostic notation. The enum value of the assertion field is calculated to be 2 by following the algorithm described in section 9.6.4.2 of {{RFC7950}}.
Four dots ("....") in a CBOR byte string denotes a sequence of bytes that are not shown for brevity.

INSERT_FIG_FROM_FILE examples/voucher-request-example1.txt END

## Voucher artifact

The voucher's primary purpose is to securely assign a Pledge to an
owner.  The voucher informs the Pledge which entity it should
consider to be its owner.

### Tree Diagram

The following diagram is largely a duplicate of the contents of {{RFC8366}},
with only the addition of the fields pinned-domain-pubk and pinned-domain-pubk-sha256.

INSERT_FIG_FROM_FILE ietf-voucher-constrained-tree.txt END

Table 3 mapping from yang type to CBOR type for voucher.

The CBOR text string of the dates MUST conform to the specification of section 3 in {{RFC6021}}.

### VK values

INSERT_FIG_FROM_FILE ietf-voucher-constrained-sid.txt END

Table 4 mapping fron yang identifier to Voucher Key (VK) for voucher

### YANG Module {#yang-voucher}

In the constrained-voucher YANG module, the voucher is "augmented" within the "used" grouping statement such that one continuous set of VK values is generated for the constrained-voucher module name, all voucher attributes, and the constrained-voucher attributes.
Two attributes of the voucher are "refined" to be optional.

INSERT_FIG_FROM_FILE ietf-constrained-voucher@DATE.yang END

### Example voucher artifacts {#example1}

Below the CBOR serialization of an example constrained voucher is shown in CBOR diagnostic notation.
The enum value of the assertion field is calculated to be zero by following the algorithm described in section 9.6.4.2 of {{RFC7950}}.
Four dots ("....") in a CBOR byte string denotes a sequence of bytes that are not shown for brevity.

INSERT_FIG_FROM_FILE examples/voucher-example1.txt END

## Signing voucher and voucher-request artifacts with COSE

The COSE_Sign1 structure is discussed in {{Section 4.2 of I-D.ietf-cose-rfc8152bis-struct}}.
The CBOR object that carries the body, the signature, and the information about the body  and signature is called the COSE_Sign1 structure.
It is used when only one signature is used on the body.

Support for ECDSA with SHA2-256 using curve secp256r1 (aka prime256k1) is RECOMMENDED.
Most current low power hardware has support for acceleration of this algorithm.
Future hardware designs could omit this in favour of a newer algorithms.
This is the ES256 keytype from Table 1 of {{I-D.ietf-cose-rfc8152bis-algs}}.
Support for curve secp256k1 is OPTIONAL.

Support for EdDSA using Curve 25519 is RECOMMENDED in new designs if hardware support is available.
This is keytype EDDSA (-8) from Table 2 of {{I-D.ietf-cose-rfc8152bis-algs}}.  A "crv" parameter is necessary to specify the Curve, which from Table 18.  The 'kty' field MUST be present, and it MUST be 'OKP'. (Table 17)

A transition towards EdDSA is occuring in the industry.
Some hardware can accelerate only some algorithms with specific curves, other hardware can accelerate any curve, and still other kinds of hardware provide a tool kit for acceleration of any eliptic curve algorithm.

In general, the Pledge is expected to support only a single algorithm, while the Registrar, usually not constrained, is expected to support a wide variety of algorithms: both legacy ones and up-and-coming ones via regular software updates.

An example of the supported COSE_Sign1 object structure is shown in {{fig-cose}}.

~~~~
COSE_Sign1(
  [
    h'A101382E',        # protected header encoding: {1: -47} , which means { "alg": ES256K }
    {
      4 : h'7890A03F1234'       # 4 is the "kid" binary key identifier
    },
    h'1234....5678', #voucher-request binary content (CBOR)
    h'4567....1234'  #voucher-request binary public signature
  ]
)
~~~~
{: #fig-cose title='COSE_Sign1 example in CBOR diagnostic notation' align="left"}

The {{COSE-registry}} specifies the integers/encoding for the "alg" and "kid" fields in {{fig-cose}}. The "alg"
field restricts the key usage for verification of this COSE object to a particular cryptographic algorithm.

The "kid" field is optionally present: it is an unprotected field that identifies the public key of the key pair that was used to sign this
message. The value of the key identifier "kid" parameter is an example value.
Usually a hash of the public key is used to identify the public key, but a device serial number may also be used. The choice of key identifier method is
vendor-specific. If "kid" is not present, then a verifying party needs to use other context information to
retrieve the right public key to verify the COSE_Sign1 object against. For example, this context information
may be a unique serial number encoded in the binary content (CBOR) field.

A Registrar MAY use a "kid" parameter in its RVR to identify its signing key as used to sign the RVR.
The method of generating this "kid" is vendor-specific and SHOULD be configurable in the Registrar to
support commonly used methods.
In order to support future business cases and supply chain integrations, a Registrar MUST be configurable, on a per-manufacturer basis, to be able to configure the "kid" to a particular value.
Both binary and string values are to be supported, each being inserted using a CBOR bstr or tstr.
By default, a Registrar does not include a "kid" parameter in its RVR since the signing key
is already identified by the included signing certificates in the COSE "x5bag" structure.

A Pledge normally SHOULD NOT use a "kid" parameter in its PVR, because its signing key is already identified
by the Pledge's unique serial number that is included in the PVR. Still, where needed the Pledge MAY use
a "kid" parameter in its PVR to help the MASA identify the right public key to verify against. This can occur
for example if a Pledge has multiple IDevID identities.
A Registrar normally SHOULD ignore a "kid" parameter used in a received PVR, as this information is intended for the MASA.
In other words, there is no need for the Registrar to verify the contents of this field, but it may include it in an audit log.

In {{cosesign}} a binary COSE_Sign1 object is shown based on the voucher-request example of {{example2}}.

# Design Considerations

The design considerations for the CBOR encoding of vouchers are much the same as for JSON vouchers in {{RFC8366}}.
One key difference is that the names of the leaves in the YANG definition do not affect the size of the resulting CBOR, as the VK translation process assigns integers to the names.

Any POST request to the Registrar with resource /vs or /es returns a 2.04 Changed response with empty payload. The client should be aware that the server may use a piggybacked CoAP response (ACK, 2.04) but may also respond with a separate CoAP response, i.e. first an (ACK, 0.0) that is an acknowledgement of the request reception followed by a (CON, 2.04) response in a separate CoAP message.

# Raw Public Key Use Considerations {#rpk-considerations}

This section explains techniques to reduce the number of bytes that are sent over the wire during the BRSKI bootstrap.
The use of a raw public key (RPK) in the pinning process can significantly reduce the number of bytes and round trips, but it comes with a few significant operational limitations.

## The Registrar Trust Anchor

When the Pledge first connects to the Registrar, the connection to the Registrar is provisional, as explained in {{Section 5.6.2 of RFC8995}}.
The Registrar provides its public key in a TLSServerCertificate, and the Pledge uses that to validate that integrity of the (D)TLS connection, but it does not validate the identity of
the provided certificate.

As the TLSServerCertificate object is never verified directly by the pledge, sending it can be considered superfluous.
Instead of using a (TLSServer)Certificate of type X509 (see section 4.4.2 of {{RFC8446}}),
a RawPublicKey object is used.

A Registrar operating in a mixed environment can determine whether to send a Certificate or a Raw Public key: this is determined by the pledge including the server\_certificate\_type of RawPublicKey.
This is shown in section 5 of {{RFC7250}}.

The Pledge continues to send a client\_certificate\_type of X509, so that the Registrar can properly identify the pledge and distill the MASA URI information from its certificate.

## The Pledge Voucher Request

The Pledge puts the Registrar's public key into the proximity-registrar-pubk
field of the voucher-request.
(The proximity-registrar-pubk-sha256 can also be used if the 32-bytes of a SHA256 hash turns out to be smaller than a typical ECDSA key.)

As the format of the pubk field is identical to the TLS Certificate RawPublicKey, no manipulation at all is needed to insert this into a voucher-request.

## The Voucher Response

A returned voucher will have a pinned-domain-subk field with the identical key as was found in the proximity-registrar-pubk field above, as well as in the TLS connection.

Validation of this key by the pledge is what takes the DTLS connection out of the provisional state see {{Section 5.6.2 of RFC8995}}.

The voucher needs to be validated first.
The Pledge needs to have a public key to validate the signature from the MASA on the voucher.

In certain cases, the MASA's public key counterpart of the (private) signing key is already installed in the Pledge at manufacturing time.
In other cases, if the MASA signing key is based upon a PKI (see {{I-D.richardson-anima-masa-considerations}} Section 2.3), then a certificate chain may need to be included with the voucher in order for the pledge to validate the signature.
In CMS signed artifacts, the CMS structure has a place for such certificates.

In the COSE-signed Constrained Vouchers described in this document, the x5bag attribute from {{I-D.ietf-cose-x509}} is to be used for this.

# Security Considerations

## Clock Sensitivity

TBD.

## Protect Voucher PKI in HSM

TBD.

## Test Domain Certificate Validity when Signing

TBD.

# IANA Considerations

## Resource Type Registry

Additions to the sub-registry "Resource Type Link Target Attribute Values", within the "CoRE parameters" IANA registry are specified below.

     brski    needs registration with IANA
     brski.rv needs registration with IANA
     brski.vs needs registration with IANA
     brski.es needs registration with IANA

## The IETF XML Registry

This document registers two URIs in the IETF XML registry {{RFC3688}}.
Following the format in {{RFC3688}}, the following registration is requested:

      URI: urn:ietf:params:xml:ns:yang:ietf-constrained-voucher
      Registrant Contact: The ANIMA WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.

      URI: urn:ietf:params:xml:ns:yang:ietf-constrained-voucher-request
      Registrant Contact: The ANIMA WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.

## The YANG Module Names Registry

This document registers two YANG modules in the YANG Module Names registry {{RFC6020}}.  Following the format defined in {{RFC6020}}, the the following registration is requested:

      name:         ietf-constrained-voucher
      namespace:    urn:ietf:params:xml:ns:yang:ietf-constrained-voucher
      prefix:       vch
      reference:    RFC XXXX

      name:         ietf-constrained-voucher-request
      namespace:    urn:ietf:params:xml:ns:yang:ietf-constrained
                                               -voucher-request
      prefix:       vch
      reference:    RFC XXXX


## Media Types Registry

This section registers the 'application/voucher-cose+cbor' in the IANA "Media Types" registry.
This media type is used to indicate that the content is a CBOR voucher or voucher request
signed with a COSE_Sign1 structure {{I-D.ietf-cose-rfc8152bis-struct}}.

### application/voucher-cose+cbor

    Type name:  application
    Subtype name:  voucher-cose+cbor
    Required parameters:  none
    Optional parameters:  none
    Encoding considerations:  binary (CBOR)
    Security considerations:  Security Considerations of THIS RFC.
    Interoperability considerations:  The format is designed to be
      broadly interoperable.
    Published specification:  THIS RFC.
    Applications that use this media type:  ANIMA, 6tisch, and other
      zero-touch onboarding systems
   Fragment identifier considerations:  The syntax and semantics of
      fragment identifiers specified for application/voucher-cose+cbor are
      as specified for application/cbor.  (At publication of this
      document, there is no fragment identification syntax defined for
      application/cbor.)
    Additional information:
      Magic number(s):  None
      File extension(s):  .vch
      Macintosh file type code(s):  none
    Person & email address to contact for further information:  IETF
      ANIMA Working Group (anima@ietf.org) or IETF Operations and
         Management Area Working Group (opsawg@ietf.org)
    Intended usage:  LIMITED [^ouch2]
    Restrictions on usage:  NONE
    Author:  ANIMA WG
    Change controller:  IETF
    Provisional registration? (standards tree only):  NO

[^ouch2]: Is this just for an experiment then?
    ("Intended usage: One of COMMON, LIMITED USE, or OBSOLETE.")


## CoAP Content-Format Registry

Additions to the sub-registry "CoAP Content-Formats", within the "CoRE
Parameters" registry are needed for two media types. These can be registered
either in the Expert Review range (0-255) or IETF Review range (256-9999).

    Media type                    Encoding   ID  References
    ----------------------------  --------- ---- ----------
    application/voucher-cose+cbor -         TBD3  [This RFC]

# Acknowledgements

We are very grateful to Jim Schaad for explaining COSE and CMS choices.
Also thanks to Jim Schaad for correcting earlier version of the COSE Sign1 objects.

Michel Veillette did extensive work on _pyang_ to extend it to support the SID allocation process proposed in {{I-D.ietf-core-sid}}. Many of his results have been taken over in this document.


# Changelog

-14
    SID allocation process is not necessary. Switch to VK assignment.
-10
    Design considerations extended
    Examples made consistent

-08
    Examples for cose_sign1 are completed and improved.

-06
    New SID values assigned; regenerated examples

-04
    voucher and request-voucher MUST be signed
    examples for signed request are added in appendix
    IANA SID registration is updated
    SID values in examples are aligned
    signed cms examples aligned with new SIDs

-03

    Examples are inverted.

-02

    Example of requestvoucher with unsigned appllication/cbor is added
    attributes of voucher "refined" to optional
    CBOR serialization of vouchers improved
    Discovery port numbers are specified

-01

    application/json is optional, application/cbor is compulsory
    Cms and cose mediatypes are introduced

--- back

#Library support for BRSKI {#libsup}

For the implementation of BRSKI, the use of a software library to manipulate certificates and use crypto algorithms is often beneficial. Two C-based examples are OPENSSL and mbedtls. Others more targeted to specific platforms or languages exist. It is important to realize that the library interfaces differ significantly between libraries.

Libraries do not support all known crypto algorithms. Before deciding on a library, it is important to look at their supported crypto algorithms and the roadmap for future support. Apart from availability, the library footprint, and the required execution cycles should be investigated beforehand.

The handling of certificates usually includes the checking of a certificate chain. In some libraries, chains are constructed and verified on the basis of a set of certificates, the trust anchor (usually self signed root CA), and the target certificate. In other libraries, the chain must be constructed beforehand and obey order criteria. Verification always includes the checking of the signatures. Less frequent is the checking the validity of the dates or checking the existence of a revoked certificate in the chain against a set of revoked certificates. Checking the chain on the consistency of the certificate extensions which specify the use of the certificate usually needs to be programmed explicitly.

A libary can be used to construct a (D)TLS connection. It is useful to realize that differences beetween (D)TLS implementations will occur due to the differences in the certicate checks supported by the library. On top of that, checks between client and server certificates enforced by (D)TLS are not always helpful for a BRSKI implementation. For example, the certificates of Pledge and Registrar are usually not related when the BRSKI protocol is started. It must be verified that checks on the relation between client and server certificates do not hamper a succeful DTLS connection establishment.

## OpensSSL

from openssl's apps/verify.c

INSERT_CODE_FROM_FILE examples/openssl-verify.c END


## mbedTLS


~~~~
    mbedtls_x509_crt cert;
    mbedtls_x509_crt caCert;
    uint32_t         certVerifyResultFlags;
    ...
    int result = mbedtls_x509_crt_verify(&cert, &caCert, NULL, NULL,
                                 &certVerifyResultFlags, NULL, NULL);
~~~~

## wolfSSL

To be added (TBD).


#Constrained BRSKI-EST messages

This section extends the examples from Appendix A of {{I-D.ietf-ace-coap-est}} with the constrained BRSKI requests. The CoAP headers are only worked out for the enrollstatus example.

##enrollstatus {#es}

A coaps enrollstatus message can be :

~~~
    POST coaps://192.0.2.1:8085/b/es
~~~

The corresponding CoAP header fields are shown below.

~~~
  Ver = 1
  T = 0 (CON)
  Code = 0x02 (0.02 is POST)
  Options
   Option  (Uri-Path)
     Option Delta = 0xb   (option nr = 11)
     Option Length = 0x1
     Option Value = "b"
   Option  (Uri-Path)
     Option Delta = 0x0   (option nr = 11)
     Option Length = 0x2
     Option Value = "es"
   Option  (Content-Format)
     Option Delta = 0x1   (option nr = 12)
     Option Length = 0x1
     Option Value = 60    (application/cbor)
  Payload Marker = 0xFF
  Payload = <binary CBOR enrollstatus document>
~~~

The Uri-Host and Uri-Port Options are omitted because they coincide with the transport protocol destination address and port respectively.
TBD - Show the binary CBOR payload of this example.

A 2.04 Changed response from the Registrar will then be:

~~~
   2.04 Changed
~~~

With CoAP fields:

~~~
   Ver=1
   T=2 (ACK)
   Code = 0x44 (2.04 Changed)
~~~

##voucher_status

A coaps voucher_status message can be:

~~~~
   POST coaps://[2001:db8::2:1]:61616/b/vs
     Content-Format: 60 (application/cbor)
     Payload =
INSERT_TEXT_FROM_FILE examples/voucher-status.hex END
~~~~

The request payload above is binary CBOR but represented here in hexadecimal for readability. Below is the equivalent CBOR diagnostic format.

~~~~
INSERT_TEXT_FROM_FILE examples/voucher-statusdiag.txt END
~~~~

A 2.04 Changed response without payload will then be sent by the Registrar back to the Pledge.

~~~~
   2.04 Changed
~~~~

# COSE examples {#cosesign}

These examples are generated on a Pi 4 and a PC running BASH. Keys and Certificates have been generated with openssl with the following shell script:

INSERT_FIG_FROM_FILE examples/brski-cert.sh END

The xxxx-comb certificates have been generated as required by libcoap for the DTLS connection generation.

## Pledge, Registrar and MASA keys

This first section documents the public and private keys used in the
subsequent test vectors below.  These keys come from test code and are not used in any
production system, and should only be used only to validate implementations.

### Pledge private key

INSERT_FIG_FROM_FILE examples/pledge-key.txt END

### Registrar private key {#jrcpriv}

INSERT_FIG_FROM_FILE examples/registrar-key.txt END

### MASA private key {#masapriv}

INSERT_FIG_FROM_FILE examples/masa-key.txt END

## Pledge, Registrar and MASA certificates

Below the certificates that accompany the keys. The certificate description is followed by the hexadecimal DER of the certificate

### Pledge IDevID certificate

INSERT_FIG_FROM_FILE examples/pledge-cert.txt END

This is the hexadecimal representation in (request-)voucher examples referred to as pledge-cert-hex.

INSERT_FIG_FROM_FILE examples/pledge-cert.hex END

### Registrar Certificate

INSERT_FIG_FROM_FILE examples/registrar-cert.txt END

This the hexadecimal representation, in (request-)voucher examples referred to as regis-cert-hex

INSERT_FIG_FROM_FILE examples/registrar-cert.hex END

### MASA Certificate

INSERT_FIG_FROM_FILE examples/masa-cert.txt END

This is the hexadecimal representation, in (request-)voucher examples referred to as masa-cert-hex.

INSERT_FIG_FROM_FILE examples/masa-cert.hex END


## COSE signed voucher request from Pledge to Registrar

In this example the voucher request has been signed by the Pledge, and has been sent to the JRC over CoAPS.
The Pledge uses the proximity assertion together with an included proximity-registrar-cert field to inform
MASA about its proximity to the specific Registrar.

~~~
    POST coaps://registrar.example.com/b/rv
    (Content-Format: application/voucher-cose+cbor)
    signed_request_voucher
~~~

The payload signed_request_voucher is shown as hexadecimal dump (with lf added):

INSERT_CODE_FROM_FILE examples/pledge-to-regis.txt END

The representiation of signed_voucher_request in CBOR diagnostic format is:

INSERT_CODE_FROM_FILE examples/pledge-to-regisdiag.txt END


## COSE signed voucher request from Registrar to MASA

TBD - modify example to use full paths to MASA, not short-names.
Also not use CoAP but HTTP protocol.

In this example the voucher request has been signed by the JRC using the private key from
{{jrcpriv}}.  Contained within this voucher request is the voucher
request from the Pledge to JRC.


~~~
    POST coaps://masa.example.com/b/rv
    (Content-Format: application/voucher-cose+cbor)
    signed_masa_request_voucher
~~~


The payload signed_masa_voucher_request is shown as hexadecimal dump (with lf added):

INSERT_CODE_FROM_FILE examples/regis-to-MASA.txt END

The representiation of signed_masa_voucher_request in CBOR diagnostic format is:

INSERT_CODE_FROM_FILE examples/regis-to-MASAdiag.txt END

## COSE signed voucher from MASA to Pledge via Registrar

The resulting voucher is created by the MASA and returned via the JRC to the
Pledge.  It is signed by the MASA's private key {{masapriv}} and can be
verified by the Pledge using the MASA's public key contained within the MASA certificate.

This is the raw binary signed_voucher, encoded in hexadecimal (with lf added):

INSERT_FIG_FROM_FILE examples/voucher-from-MASA.txt END

The representiation of signed_voucher in CBOR diagnostic format is:

INSERT_FIG_FROM_FILE examples/voucher-from-MASAdiag.txt END
