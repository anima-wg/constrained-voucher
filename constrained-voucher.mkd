---
title: Constrained Voucher Artifacts for Bootstrapping Protocols
abbrev: Constrained Voucher
docname: draft-ietf-anima-constrained-voucher-13

stand_alone: true

ipr: trust200902
area: Internet
wg: anima Working Group
kw: Internet-Draft
cat: std
consensus: true

pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:

- ins: M. Richardson
  name: Michael Richardson
  org: Sandelman Software Works
  email: mcr+ietf@sandelman.ca

- ins: P. van der Stok
  name: Peter van der Stok
  org: vanderstok consultancy
  email: stokcons@bbhmail.nl

- ins: P. Kampanakis
  name: Panos Kampanakis
  org: Cisco Systems
  email: pkampana@cisco.com

- ins: E. Dijk
  name: Esko Dijk
  org: IoTconsultancy.nl
  email: esko.dijk@iotconsultancy.nl

contributor:
  - name: Russ Housley
    email: housley@vigilsec.com

normative:
#  RFC2119:
  RFC8949:
  I-D.ietf-core-yang-cbor:
  I-D.ietf-core-sid:
  RFC7250:
  RFC8446:
#  RFC7252:
  RFC7950:
  RFC5652:
#  RFC8174:
  RFC8366:
  RFC3688:
  RFC6020:
  I-D.ietf-cose-rfc8152bis-struct:
  BRSKI: RFC8995
  RFC9031: minimal-security
#  I-D.ietf-core-object-security:
#  I-D.ietf-ace-cbor-web-token:
  I-D.ietf-ace-coap-est:
  I-D.ietf-cose-x509:
### Unused?  XXX
  ieee802-1AR:
    target: "http://standards.ieee.org/findstds/standard/802.1AR-2009.html"
    title: "IEEE 802.1AR Secure Device Identifier"
    author:
      ins: "IEEE Standard"
    date: 2009

informative:
  RFC8340: yang-tree
# was  I-D.ietf-netmod-yang-tree-diagrams:
#  pledge:
#    title: "Dictionary.com Unabridged"
#    target: "http://dictionary.reference.com/browse/pledge"
#    author:
#      -
#        name: Dictionary.com
#    date: 2015

#  duckling:
#    title: "The resurrecting duckling: security issues for ad-hoc wireless networks"
#    target: "https://www.cl.cam.ac.uk/~fms27/papers/1999-StajanoAnd-duckling.pdf"
#    author:
#      -
#        ins: F. Stajano
#        name: Frank Stajano
#      -
#        ins: R. Anderson
#        name: Ross Anderson
#    date: 1999

  COSE-registry:
    title: "CBOR Object Signing and Encryption (COSE) registry"
    target: "https://www.iana.org/assignments/cose/cose.xhtml"
    author:
      ins: "IANA"
    date: 2017
  I-D.richardson-anima-masa-considerations:
  RFC6690:
  RFC7030:

--- abstract

This document defines a protocol to securely assign a Pledge to an
owner and to enroll it into the owner's network.
The protocol uses an artifact that is signed by the Pledge's manufacturer.
This artifact is known as a "voucher".

This document builds upon the work in [RFC8366] and [BRSKI], but defines an encoding of
the voucher in CBOR rather than JSON, and enables the Pledge to perform its transactions using CoAP rather than HTTPS.

The use of Raw Public Keys instead of X.509 certificates for security operations is also explained.

--- middle

# Introduction

Secure enrollment of new nodes into constrained networks with constrained nodes
presents unique challenges. There are network bandwidth and code size issues to contend with.
A solution for autonomous enrollment such as BRSKI {{BRSKI}} may be too large in terms of
code size or bandwidth required.

Therefore, this document defines a constrained version of the voucher artifact {{RFC8366}}, along with a constrained version of {{BRSKI}} that makes use of the constrained CoAP-based version of EST, EST-coaps {{I-D.ietf-ace-coap-est}} rather than EST over HTTPS {{RFC7030}}.

While the {{RFC8366}} voucher is by default serialized to JSON with a signature in CMS {{RFC5652}},
this document defines a new voucher serialization to CBOR {{RFC8949}} with a signature in COSE {{I-D.ietf-cose-rfc8152bis-struct}}.
This COSE-signed CBOR-encoded voucher can be transported using secured CoAP or HTTP.
The CoAP connection (between Pledge and Registrar) is to be protected by either OSCORE+EDHOC or DTLS (CoAPS).
The HTTP connection (between Registrar and MASA) is to be protected using TLS (HTTPS).

This document specifies a constrained voucher-request artifact based on Section 3 of {{BRSKI}}, and
voucher(-request) transport over CoAP based on Section 3 of {{BRSKI}} and on {{I-D.ietf-ace-coap-est}}.

The CBOR definitions for the constrained voucher format are defined using the mechanism described in {{I-D.ietf-core-yang-cbor}} using the SID mechanism explained in {{I-D.ietf-core-sid}}.
As the tooling to convert YANG documents into a list of SID keys is still in its infancy, the table of SID values presented here MUST be considered normative rather than the output of the pyang tool.

There is additional work when the voucher is integrated into the key-exchange, described in {{!I-D.selander-ace-ake-authz}}.
This work is not in scope for this document.

# Terminology          {#Terminology}

The following terms are defined in {{RFC8366}}, and are used identically as in that document:
artifact, domain, imprint, Join Registrar/Coordinator (JRC), Manufacturer Authorized Signing Authority
(MASA), Pledge, Registrar, Trust of First Use (TOFU), and Voucher.

The following terms from {{BRSKI}} are used identically as in that document:
Domain CA, enrollment, IDevID, Join Proxy, LDevID, manufacturer, nonced, nonceless, PKIX.

The term "raw voucher request" is introduced to refer to the voucher request between the pledge and the Registrar.

The term "parboiled voucher request" is introduced to refer to the voucher request between the Registrar and the MASA.

# Requirements Language {#reqlang}

{::boilerplate bcp14}

# Overview of Protocol {#survey}

{{RFC8366}} provides for vouchers that assert proximity, that authenticate the Registrar and that can offer varying levels of anti-replay protection.

This document does not make any extensions to the semantic meaning of vouchers, only the encoding has been changed to optimize for constrained devices and networks.
The two main parts of the BRSKI protocol are named separately in this document: BRSKI-EST for the protocol between Pledge and Registrar, and BRSKI-MASA for the
protocol between the Registrar and the MASA.

Time-based vouchers are supported in this definition, but given that constrained devices are extremely unlikely to have accurate time, their use will be uncommon.
Most Pledges using these constrained vouchers will be online during enrollment and will use live nonces to provide anti-replay protection rather than expiry times.

{{RFC8366}} defines the voucher artifact, while the Voucher Request artifact was defined in {{BRSKI}}.
This document defines both a constrained voucher and a constrained voucher-request.
They are presented in the order "voucher-request", followed by a "voucher" response as this is
the order that they occur in the protocol.

The constrained voucher request MUST be signed by the Pledge.
It signs using the private key associated with its IDevID X.509 certificate, or if an IDevID is not available, then the private key associated with its manufacturer-installed raw public key (RPK).
{{rpk-considerations}} provides additional details on PKIX-less operations.

The constrained voucher MUST be signed by the MASA.

For the constrained voucher request this document defines two distinct methods for the Pledge to identify the Registrar: using either the Registrar's X.509 certificate, or using a raw public key (RPK) of the Registrar.

For the constrained voucher also these two methods are supported to indicate (pin) a trusted domain identity: using either a pinned domain X.509 certificate, or a pinned raw public key (RPK).

The BRSKI architectures mandates that the MASA be aware of the capabilities of the pledge.
This is not a hardship as the pledges are constructed by a manufacturer who also arranges for the MASA to be aware of the inventory of devices.

The MASA therefore knows if the pledge supports PKIX operations, PKIX format certificates, or if the pledge is limited to Raw Public Keys (RPK).
Based upon this, the MASA can select which attributes to use in the voucher for certain operations, like the pinning of the Registrar identity.
This is described in more detail in {{yang-voucher}}, {{pinning}} and {{pinned-with-rpk}} (for RPK specifically).

# BRSKI-EST Protocol {#brski-est}

This section describes the constrained BRSKI extensions to EST-coaps {{I-D.ietf-ace-coap-est}} to transport the voucher between Registrar and Pledge (optionally via a Join Proxy) over CoAP.
The extensions are targeting low-resource networks with small packets.

The constrained BRSKI-EST protocol described in this section is between the Pledge and the Registrar only.

## Registrar and the Server Name Indicator (SNI)

A DTLS connection is established between the pledge and the Registrar.
As described in {{section 5 of RFC8995}} the pledge establishes a TLS connection to the Registrar.
This occurs via a variety of Join Proxy mechanisms described in {{joinproxy}}.
Regardless of the mechanism, the DTLS connection should operate identically.

As the Registrar is discovered by IP address, and connected via the Join proxy, the name of the Registrar is not known to the Pledge.
The Pledge will not know what the hostname for the Registrar is, so the pledge can not do RFC6125 DNS-ID validation on the Registrar's certificate.
That is the purpose of the RFC8366 voucher.

As the Pledge does not know the name of the Registrar, the Pledge cannot put any reasonable value into the {{RFC6066}} Server Name Indicator (SNI).
The pledge SHOULD omit the SNI extension as per {{section 9.2 of RFC8446}}.

In some cases, particularly when debugging and doing interoperability testing, a Pledge may be  given the hostname of a particular Registrar to connect to.
Such a bypass of the discovery process may result in the Pledge taking a different path to DTLS connection, and may result in the SNI being inserted by a library.
The Registrar MUST ignore any SNI seen.

A primary motivation for making the SNI ubiquitous in the public web is because it allows for multi-tenant hosting of HTTPS sites on a single (scarce) IPv4 address.
This consideration does not apply to the Registrar because:

* it uses DTLS and CoAP, not HTTPS

* it uses IPv6, often {{RFC4193}} Unique Local Address, which are plentiful

* the port number number is discovered, so multiple tenants can be accomodate via unique port numbers.

As per {{RFC7030 section 3.6.1}}, the Registrar certificate MUST have the Extended Key Usage (EKU) id-kp-cmcRA.
This certificate is also used as a TLS Server Certificate, so it must also have the EKU id-kp-serverAuth.

## Discovery, URIs and Content Formats

To keep the protocol messages small the EST-coaps and constrained-BRSKI URIs are shorter than the respective EST and BRSKI URIs.

The EST-coaps server URIs differ from the EST URIs by replacing the scheme https by coaps and by specifying shorter resource path names. Below are some examples;
the first two using a discovered short path name and the last one using the well-known URI of EST which requires no discovery.

~~~~
  coaps://server.example.com/est/<short-name>
  coaps://server.example.com/e/<short-name>
  coaps://server.example.com/.well-known/est/<short-name>
~~~~

Similarly the constrained BRSKI server URIs differ from the BRSKI URIs by replacing the scheme https by coaps and by specifying shorter resource path names. Below are some examples;
the first two using a discovered short path name and the last one using the well-known URI prefix which requires no discovery.
This is the same "/.well-known/brski" prefix as defined in {{BRSKI}} Section 5.

~~~~
  coaps://server.example.com/brski/<short-name>
  coaps://server.example.com/b/<short-name>
  coaps://server.example.com/.well-known/brski/<short-name>
~~~~

Figure 5 in section 3.2.2 of {{RFC7030}} enumerates the operations supported by EST, for which Table 1 in Section 5.1 of {{I-D.ietf-ace-coap-est}} enumerates the corresponding
EST-coaps short path names. Similarly, {{est-uri}} provides the mapping from the supported BRSKI extension URI paths to the constrained-BRSKI URI paths.

| BRSKI resource | constrained-BRSKI resource |
| /requestvoucher| /rv |
| /voucher_status | /vs |
| /enrollstatus | /es  |
{: #est-uri title='BRSKI URI paths mapping to constrained BRSKI URI paths'}

Note that /requestvoucher indicated above occurs between the Pledge and Registrar (in scope of the BRSKI-EST protocol), but it also occurs between Registrar and MASA. However,
as described in {{brski-est}}, this section and above table addresses only the BRSKI-EST protocol.

Pledges that wish to discover the available BRSKI bootstrap options/formats, or reduce the size of the CoAP headers by eliminating the "/.well-known/brski" path, can do a discovery operation using {{RFC6690}} Section 4 by sending a discovery query to the Registrar.

For example, if the Registrar supports a short BRSKI URL (/b) and supports the voucher format "application/voucher-cose+cbor" (TBD3), and status reporting in both CBOR and JSON formats:

~~~~
  REQ: GET /.well-known/core?rt=brski*

  RES: 2.05 Content
  Content-Format: 40
  Payload:
  </b>;rt=brski,
  </b/rv>;rt=brski.rv;ct=TBD3,
  </b/vs>;rt=brski.vs;ct="50 60",
  </b/es>;rt=brski.es;ct="50 60"
~~~~

The Registrar is under no obligation to provide shorter URLs, and MAY respond to this query with only the "/.well-known/brski/\<short-name\>" end points for the short names as defined in {{est-uri}}.

Registrars that have implemented shorter URLs MUST also respond in equivalent ways to the corresponding "/.well-known/brski/\<short-name\>" URLs, and MUST NOT distinguish between them.
In particular, a Pledge MAY use the longer and shorter URLs in combination.

When responding to a discovery request for BRSKI resources, the server MAY in addition return
the full resource paths and the content types which are supported at those end-points as shown in above example.
This is useful when multiple content types are specified for a particular resource on the server.
The server responds with only the root path for the BRSKI resource (rt=brski, resource /b in above example) and no others in case the client queries for only rt=brski type resources.
(So, a query for rt=brski, without the wildcard character.)

The return of multiple content-types in the "ct" attribute allows the Pledge to choose the most appropriate one.
Note that Content-Format TBD3 ("application/voucher-cose+cbor") is defined in this document.

The Content-Format 50 ("application/json") MAY be supported and Content-Format 60 ("application/cbor") MUST be supported by the Registrar for the /vs and /es resources.
Content-Format TBD3 MUST be supported by the Registrar for the /rv resource.
If the "ct" attribute is not indicated for the /rv resource in the link format description, this implies that at least TBD3 is supported.

The Pledge and MASA need to support one or more formats (at least TBD3) for the voucher and for the voucher request.
The MASA needs to support all formats that the Pledge, produced by that manufacturer, supports.

## Join Proxy options {#joinproxy}

## Extensions to BRSKI {#brski-extensions}

A Pledge that only supports the BRSKI bootstrap method and already knows the IP address and port of a Registrar or Join Proxy to use SHOULD NOT use discovery.
In such case it is more efficient to just try its supported bootstrap method (e.g. /rv) via the well-known BRSKI resource on the known address and port. This avoids
the Pledge having to unnecessarily implement CoRE Link Format parsing. The method via which the Pledge learns the address/port of a Registrar or Join Proxy to use
is out of scope of this document.

A Registrar SHOULD host any discoverable BRSKI resources on the same (UDP) server port that the Pledge's initial DTLS connection is using.
This avoids the overhead of the Pledge having to reconnect using DTLS, in order to access discovered resource(s).

## Extensions to EST-coaps {#brski-est-extensions}

A Pledge that already is DTLS-connected to either a Join Proxy or Registrar, and which only supports the EST-coaps enrollment method, SHOULD NOT use discovery for EST-coaps resources.
This is because it is more efficient to just try its supported enrollment method (e.g. /sen) via the well-known EST resource on the current DTLS connection.
This avoids an additional round-trip of packets and avoids the Pledge having to unnecessarily implement CoRE Link Format parsing.

A Registrar SHOULD host any discoverable EST-coaps resources on the same (UDP) server port that the Pledge's DTLS initial connection is using.
This avoids the Pledge having to reconnect using DTLS, in order to proceed with EST enrollment after the BRSKI bootstrap.
[TBD EDNOTE: a Registrar that does host EST resources on another port won't be able to onboard Pledges that skip the discovery, so not interoperable. Should we fix this?]

### Pledge Extensions {#brski-extensions-pledge}

A constrained Pledge SHOULD NOT support the optional EST "CSR attributes request" (/att) to minimize network traffic and reduce code size.

When creating the CSR, the Pledge selects which attributes to include. One or more Subject Distinguished Name fields MUST be included.
If the Pledge has no specific information on what attributes/fields are desired in the CSR, it MUST use the Subject Distinguished Name fields from its IDevID unmodified.
The Pledge can receive such information via the voucher (encoded in a vendor-specific way) or some other, out-of-band means.

A constrained Pledge MAY use the following optimized EST-coaps procedure to minimize both network traffic and code size:

1. if the voucher, that validates the current Registrar, contains a single pinned domain CA certificate, the Pledge provisionally considers this certificate as the EST trust anchor, in other words,
it provisionally accepts this CA certificate as if it were the result of "CA certificates request" (/crts) to the Registrar.

2. Using this CA certificate as trust anchor it proceeds with EST simple enrollment (/sen) to obtain its provisionally trusted LDevID.

3. If the Pledge validates that the trust anchor CA was used to sign its LDevID, the Pledge accepts the pinned domain CA certificate as the legitimate trust anchor CA for the Registrar's domain and accepts the associated LDevID.

4. If the trust anchor CA was NOT used to sign its LDevID, the Pledge MUST perform an actual "CA certificates request" (/crts) to the EST server to obtain the EST CA trust anchor(s) since these differ from the (temporary) pinned domain CA.

5. When doing this /crts request, the Pledge MAY use a CoAP Accept Option with value TBD287 ("application/pkix-cert") to limit the number of returned EST CA trust anchors to only one.

7. If the Pledge cannot obtain the single CA certificate or the finally validated CA certificate cannot be chained to the LDevID, then the Pledge MUST abort the enrollment process and report the error using the enrollment status telemetry (/es).

<!-- ******************************************************************** -->

### Registrar Extensions

The Content-Format 50 MAY be supported and 60 MUST be supported by the Registrar for the /vs and /es resources.
Content-Format TBD3 MUST be supported by the Registrar for the /rv resource.

When a Registrar receives a "CA certificates request" (/crts) request with a CoAP Accept Option with value TBD287 ("application/pkix-cert") it SHOULD return only the
single CA certificate that is the envisioned or actual authority for the current, authenticated Pledge making the request. The only exception case
is when the Registrar is configured to not support a request for a single CA certificate for operational or security reasons, e.g. because every device
enrolled into the domain needs to use multiple CAs.
In such exception case the Registrar returns the CoAP response 4.06 Not Acceptable to indicate
that only the default Content-Format of 281 "application/pkcs7-mime;smime-type=certs-only" which supports multiple certificates is available.

# BRSKI-MASA Protocol {#brski-masa}

{{BRSKI}} section 5.4 describes a connection between the Registrar and the MASA as being a normal TLS connection using HTTPS.
This document does not change that. The Registrar MAY use the new format "application/voucher-cose+cbor" in its voucher request to MASA, or the existing BRSKI
format "application/voucher-cms+json" defined by {{BRSKI}}.

The MASA only needs to support formats for which there are Pledges that use that format.

The Registrar MUST use the same format of parboiled voucher-request as the Pledge's raw voucher-request.

The Registrar indicates the voucher
format it wants to receive from MASA using the HTTP Accept header.

At the moment of writing the creation of coaps based MASAs is deemed unrealistic.
The use of CoAP for the BRSKI-MASA connection can be the subject of another document.
Some consideration was made to specify CoAP support for consistency, but:

* the Registrar is not expected to be so constrained that it cannot support HTTPS client connections.

* the technology and experience to build Internet-scale HTTPS responders (which the MASA is) is common, while the experience doing the same for CoAP is much less common.

* in many Enterprise networks, outgoing UDP connections are often treated as suspicious, and there seems to be no advantage to using CoAP in that environment.

* a Registrar is likely to provide onboarding services to both constrained and non-constrained devices.  Such a Registrar would need to speak HTTPS anyway.

* similarly, a manufacturer is likely to offer both constrained and non-constrained devices, so there may in practice be no situation in which the MASA could be CoAP-only.  Additionally, as the MASA is intended to be a function that can easily be oursourced to a third-party service provider, reducing the complexity would also seem to reduce the cost of that function.

<!-- ******************************************************************** -->

# Pinning in Voucher Artifacts {#pinning}

The voucher is a statement by the MASA for use by the Pledge that provide the identity of the Pledge's owner.
This section describes how the owner's identity is determined and how it is encoded within the voucher.

## Registrar Identity Selection and Encoding

Section 5.5 of {{BRSKI}} describes BRSKI policies for selection of the owner identity. It indicates some of the flexibility that is possible for the Registrar.

The recommendation made there is for the Registrar to include only certificates in the voucher request (CMS) signing structure that participate in the certificate chain that is to be pinned.

The MASA is expected to evaluate the certificates included by the Registrar in its voucher request, forming them into a chain with the Registrar's (signing) identity on one end. Then, it pins a certificate selected from the chain.
For instance, for a domain with a two-level certification authority (see {{fig-twoca}}), where the voucher-request has been signed by "Registrar", its signing structure includes two additional CA certificates:

~~~~
{::include two-ca-chain.txt}
~~~~
{: #fig-twoca title='Two-Level CA PKI'}

When the Registrar is using a COSE-signed constrained voucher request towards MASA, instead of a regular CMS-signed voucher request, the COSE_Sign1 object contains a protected and an unprotected header.
The Registrar MUST place all the certificates for the chain in an "x5bag" attribute in the unprotected header {{I-D.ietf-cose-x509}}.


## MASA Pinning Policy {#masa-pinning-policy}

The MASA, having assembled and verified the chain in the signing structure of the voucher request, will now need to select a certificate to pin.
(For the case that only the Registrar's End-Entity certificate is included, only this certificate can be selected and this section does not apply.)
The BRSKI policy for pinning by the MASA as described in Section 5.5.2 of {{BRSKI}} leaves much flexibility to the manufacturer. The present
document adds the following rules to the MASA pinning policy to reduce the network load:

1. for a voucher containing a nonce, it SHOULD select the most specific (lowest-level) CA certificate in the chain.
2. for a nonceless voucher, it SHOULD select the least-specific (highest-level) CA certificate in the chain that is allowed under the MASA's policy for this specific domain.

The rationale for 1. is that in case of a voucher with nonce, the voucher is valid only in scope of the present DTLS connection between Pledge and Registrar anyway, so it would have no
benefit to pin a higher-level CA. By pinning the most specific CA the constrained Pledge can validate its DTLS connection using less crypto operations. The
rationale for pinning a CA instead of the Registrar's End-Entity certificate directly is the following benefit on constrained networks: the pinned certificate in the voucher
can in common cases be re-used as a Domain CA trust anchor during the EST enrollment and during the operational phase that follows after EST enrollment, as explained in {{brski-extensions-pledge}}.

The rationale for 2. follows from the flexible BRSKI trust model for, and purpose of, nonceless vouchers (Sections 5.5.* and 7.4.1 of {{BRSKI}}).

Using the previous example of a domain with a two-level certification authority, the most specific CA ("Sub-CA") is the identity that is pinned by MASA in a nonced voucher.
A Registrar that wished to have only the Registrar's End-Entity certificate pinned would omit the "domain CA" and "Sub-CA" certificates from the voucher-request.

In case of a nonceless voucher, the MASA would depending on trust level pin only "Registrar" certificate (low trust in customer), or the "Sub-CA" certificate (in case of
medium trust, implying that any Registrar of that sub-domain is acceptable), or even the "domain CA" certificate (in case of high trust in the customer, and possibly a pre-agreed need of the
customer to obtain flexible long-lived vouchers).

## Pinning of Raw Public Keys {#pinned-with-rpk}

Specifically for constrained use cases, the pinning of the raw public key (RPK) of the Registrar is also supported in the constrained voucher, instead of an X.509 certificate.
If an RPK is pinned it MUST be the RPK of the Registrar.

When the Pledge is known by MASA to support RPK but not X.509 certificates, the voucher produced by the MASA pins the RPK of the Registrar in either the "pinned-domain-pubk"
or "pinned-domain-pubk-sha256" field of a voucher.
This is described in more detail in {{yang-voucher}}. A Pledge that does not support X.509 certificates cannot use EST to enroll; it has to use
another method for enrollment without certificates and the Registrar has to support this method also.
It is possible that the Pledge will not enroll, but instead only a network join operation will occur, such as described in {{RFC9031}}.
How the Pledge discovers this method and details of the enrollment method are out of scope of this document.

When the Pledge is known by MASA to support PKIX format certificates, the "pinned-domain-cert" field present in a voucher typically pins a domain certificate.
That can be either the End-Entity certificate of the Registrar, or the certificate of a domain CA of the Registrar's domain as specified in {{masa-pinning-policy}}.
However, if the Pledge is known to also support RPK pinning and the MASA intends to pin the Registrar's identity (not a CA), then MASA SHOULD pin the RPK (RPK3 in {{fig-pinning}}) of the Registrar instead of the Registrar's End-Entity certificate to save space in the voucher.

~~~~
{::include pinning-options.txt}
~~~~
{: #fig-pinning title='Raw Public Key pinning'}

<!-- ******************************************************************** -->

# Artifacts

This section describes for both the voucher request and
the voucher first the abstract (tree) definition as explained
in {{-yang-tree}}.  This provides a high-level
view of the contents of each artifact.

Then the assigned SID values are presented. These have been assigned using
the rules in {{I-D.ietf-core-sid}}.

## Voucher Request artifact

### Tree Diagram

The following diagram is largely a duplicate of the contents of {{RFC8366}},
with the addition of the fields proximity-registrar-pubk, proximity-registrar-pubk-sha256,
proximity-registrar-cert, and prior-signed-voucher-request.

prior-signed-voucher-request is only used between the Registrar and the MASA.
proximity-registrar-pubk or proximity-registrar-pubk-sha256 optionally replaces proximity-registrar-cert
for the most constrained cases where RPK is used by the Pledge.

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained-tree.txt END

### SID values

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained-sid.txt END

### YANG Module {#yang-voucher-request}

In the constrained-voucher-request YANG module, the voucher is "augmented" within the "used" grouping statement such that one continuous set of SID values is generated for the constrained-voucher-request module name, all voucher attributes, and the constrained-voucher-request attributes. Two attributes of the voucher are "refined" to be optional.

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained@DATE.yang END

### Example voucher request artifact {#example2}

Below is a CBOR serialization of an example constrained voucher request from a Pledge to a Registrar, shown in CBOR diagnostic notation. The enum value of the assertion field is calculated to be 2 by following the algorithm described in section 9.6.4.2 of {{RFC7950}}.
Four dots ("....") in a CBOR byte string denotes a sequence of bytes that are not shown for brevity.

INSERT_FIG_FROM_FILE examples/voucher-request-example1.txt END

## Voucher artifact

The voucher's primary purpose is to securely assign a Pledge to an
owner.  The voucher informs the Pledge which entity it should
consider to be its owner.

### Tree Diagram

The following diagram is largely a duplicate of the contents of {{RFC8366}},
with only the addition of the fields pinned-domain-pubk and pinned-domain-pubk-sha256.

INSERT_FIG_FROM_FILE ietf-voucher-constrained-tree.txt END

### SID values

INSERT_FIG_FROM_FILE ietf-voucher-constrained-sid.txt END


### YANG Module {#yang-voucher}

In the constrained-voucher YANG module, the voucher is "augmented" within the "used" grouping statement such that one continuous set of SID values is generated for the constrained-voucher module name, all voucher attributes, and the constrained-voucher attributes.
Two attributes of the voucher are "refined" to be optional.

INSERT_FIG_FROM_FILE ietf-constrained-voucher@DATE.yang END

### Example voucher artifacts {#example1}

Below the CBOR serialization of an example constrained voucher is shown in CBOR diagnostic notation.
The enum value of the assertion field is calculated to be zero by following the algorithm described in section 9.6.4.2 of {{RFC7950}}.
Four dots ("....") in a CBOR byte string denotes a sequence of bytes that are not shown for brevity.

INSERT_FIG_FROM_FILE examples/voucher-example1.txt END

## Signing voucher and voucher-request artifacts with COSE

The COSE-Sign1 structure is discussed in section 4.2 of {{I-D.ietf-cose-rfc8152bis-struct}}.
The CBOR object that carries the body, the signature, and the information about the body  and signature is called the COSE_Sign1 structure.
It is used when only one signature is used on the body.
Support for ECDSA with sha256 (secp256k1 and prime256v1 curves) is REQUIRED.
Support for EdDSA is encouraged. [TBD EDNOTE: Expand and add a reference why. ]

An example of the supported COSE-sign1 object structure is shown in {{fig-cose}}.

~~~~
COSE_Sign1(
  [
    h'A101382E',        # { "alg": ES256K }
    {
      "kid" : h'7890....1234'  # hash256(public key)
    },
    h'1234....5678', #voucher-request binary content
    h'4567....1234', #voucher-request binary public signature
  ]
)
~~~~
{: #fig-cose title='cose-sign1 example in CBOR diagnostic notation' align="left"}

The {{COSE-registry}} specifies the integers that replace the strings and the mnemonics in {{fig-cose}}.
The value of the key identifier "kid" parameter is an example value.
Usually a hash of the public key is used to identify the public key. The choice of key identifier method is
vendor-specific.
The public key and its hash are derived from the relevant certificate (Pledge, Registrar or MASA certificate).
[TBD EDNOTE: how can MASA know which kid method the Registrar has used/supports? Does it matter?]

In {{cosesign}} a binary cose-sign1 object is shown based on the voucher-request example of {{example2}}.

# Design Considerations

The design considerations for the CBOR encoding of vouchers are much the same as for JSON vouchers in {{RFC8366}}.
One key difference is that the names of the leaves in the YANG definition do not affect the size of the resulting CBOR, as the SID translation process assigns integers to the names.

Any POST request to the Registrar with resource /vs or /es returns a 2.04 Changed response with empty payload. The client should be aware that the server may use a piggybacked CoAP response (ACK, 2.04) but may also respond with a separate CoAP response, i.e. first an (ACK, 0.0) that is an acknowledgement of the request reception followed by a (CON, 2.04) response in a separate CoAP message.

# Raw Public Key Use Considerations {#rpk-considerations}

This section explains techniques to reduce the number of bytes that are sent over the wire during the BRSKI bootstrap.
The use of a raw public key (RPK) in the pinning process can significantly reduce the number of bytes and round trips, but it comes with a few significant operational limitations.

## The Registrar Trust Anchor

When the Pledge first connects to the Registrar, the connection to the Registrar is provisional, as explained in section 5.6.2 of {{BRSKI}}.
The Registrar provides its public key in a TLSServerCertificate, and the Pledge uses that to validate that integrity of the (D)TLS connection, but it does not validate the identity of
the provided certificate.

As the TLSServerCertificate object is never verified directly by the pledge, sending it can be considered superfluous.
Instead of using a (TLSServer)Certificate of type X509 (see section 4.4.2 of {{RFC8446}}),
a RawPublicKey object is used.

A Registrar operating in a mixed environment can determine whether to send a Certificate or a Raw Public key: this is determined by the pledge including the server\_certificate\_type of RawPublicKey.
This is shown in section 5 of {{RFC7250}}.

The Pledge continues to send a client\_certificate\_type of X509, so that the Registrar can properly identify the pledge and distill the MASA URI information from its certificate.

## The Pledge Voucher Request

The Pledge puts the Registrar's public key into the proximity-registrar-pubk
field of the voucher-request.
(The proximity-registrar-pubk-sha256 can also be used if the 32-bytes of a SHA256 hash turns out to be smaller than a typical ECDSA key.)

As the format of the pubk field is identical to the TLS Certificate RawPublicKey, no manipulation at all is needed to insert this into a voucher-request.

## The Voucher Response

A returned voucher will have a pinned-domain-subk field with the identical key as was found in the proximity-registrar-pubk field above, as well as in the TLS connection.

Validation of this key by the pledge is what takes the DTLS connection out of the provisional state (see {{BRSKI}} section 5.6.2).

The voucher needs to be validated first.
The Pledge needs to have a public key to validate the signature from the MASA on the voucher.

In certain cases, the MASA's public key counterpart of the (private) signing key is already installed in the Pledge at manufacturing time.
In other cases, if the MASA signing key is based upon a PKI (see {{I-D.richardson-anima-masa-considerations}} Section 2.3), then a certificate chain may need to be included with the voucher in order for the pledge to validate the signature.
In CMS signed artifacts, the CMS structure has a place for such certificates.
In the COSE-signed Constrained Vouchers described in this document, the x5bag attribute from {{I-D.ietf-cose-x509}} is to be used for this.

# Security Considerations

## Clock Sensitivity

TBD.

## Protect Voucher PKI in HSM

TBD.

## Test Domain Certificate Validity when Signing

TBD.

# IANA Considerations

## Resource Type Registry

Additions to the sub-registry "Resource Type Link Target Attribute Values", within the "CoRE parameters" IANA registry are specified below.

     brski    needs registration with IANA
     brski.rv needs registration with IANA
     brski.vs needs registration with IANA
     brski.es needs registration with IANA

## The IETF XML Registry

This document registers two URIs in the IETF XML registry {{RFC3688}}.
Following the format in {{RFC3688}}, the following registration is requested:

      URI: urn:ietf:params:xml:ns:yang:ietf-constrained-voucher
      Registrant Contact: The ANIMA WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.

      URI: urn:ietf:params:xml:ns:yang:ietf-constrained-voucher-request
      Registrant Contact: The ANIMA WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.

## The YANG Module Names Registry

This document registers two YANG modules in the YANG Module Names registry {{RFC6020}}.  Following the format defined in {{RFC6020}}, the the following registration is requested:

      name:         ietf-constrained-voucher
      namespace:    urn:ietf:params:xml:ns:yang:ietf-constrained-voucher
      prefix:       vch
      reference:    RFC XXXX

      name:         ietf-constrained-voucher-request
      namespace:    urn:ietf:params:xml:ns:yang:ietf-constrained
                                               -voucher-request
      prefix:       vch
      reference:    RFC XXXX

## The RFC SID range assignment sub-registry

    ------------ ------ --------------------------- ------------
    Entry-point | Size | Module name               | RFC Number
    ------------ ------ --------------------------- ------------
    2450          50     ietf-voucher-constrained    [ThisRFC]
    2500          50     ietf-voucher-request        [ThisRFC}
                                     -constrained
    ----------- ------  --------------------------- ------------

Warning: These SID values are defined in {{I-D.ietf-core-sid}}, not as an Early Allocation.

IANA: please update the names in the Registry to match these revised names, if they have not already  been revised.

## Media Types Registry

This section registers the 'application/voucher-cose+cbor' in the IANA "Media Types" registry.
This media type is used to indicate that the content is a CBOR voucher or voucher request
signed with a COSE_Sign1 structure {{I-D.ietf-cose-rfc8152bis-struct}}.

### application/voucher-cose+cbor

    Type name:  application
    Subtype name:  voucher-cose+cbor
    Required parameters:  none
    Optional parameters:  none
    Encoding considerations:  binary
    Security considerations:  Security Considerations of THIS RFC.
    Interoperability considerations:  The format is designed to be
      broadly interoperable.
    Published specification:  THIS RFC.
    Applications that use this media type:  ANIMA, 6tisch, and other
      zero-touch onboarding systems
    Additional information:
      Magic number(s):  None
      File extension(s):  .vch
      Macintosh file type code(s):  none
    Person & email address to contact for further information:  IETF
      ANIMA WG
    Intended usage:  LIMITED
    Restrictions on usage:  NONE
    Author:  ANIMA WG
    Change controller:  IETF
    Provisional registration? (standards tree only):  NO

## CoAP Content-Format Registry

Additions to the sub-registry "CoAP Content-Formats", within the "CoRE
Parameters" registry are needed for two media types. These can be registered
either in the Expert Review range (0-255) or IETF Review range (256-9999).

    Media type                    Encoding   ID  References
    ----------------------------  --------- ---- ----------
    application/voucher-cose+cbor           TBD3 [This RFC]


# Acknowledgements

We are very grateful to Jim Schaad for explaining COSE and CMS choices.
Also thanks to Jim Schaad for correcting earlier version of the COSE Sign1 objects.

Michel Veillette did extensive work on _pyang_ to extend it to support the SID allocation process, and this document was among its first users.


# Changelog

-10
    Design considerations extended
    Examples made consistent

-08
    Examples for cose_sign1 are completed and improved.

-06
    New SID values assigned; regenerated examples

-04
    voucher and request-voucher MUST be signed
    examples for signed request are added in appendix
    IANA SID registration is updated
    SID values in examples are aligned
    signed cms examples aligned with new SIDs

-03

    Examples are inverted.

-02

    Example of requestvoucher with unsigned appllication/cbor is added
    attributes of voucher "refined" to optional
    CBOR serialization of vouchers improved
    Discovery port numbers are specified

-01

    application/json is optional, application/cbor is compulsory
    Cms and cose mediatypes are introduced

--- back

#Library support for BRSKI {#libsup}

For the implementation of BRSKI, the use of a software library to manipulate certificates and use crypto algorithms is often beneficial. Two C-based examples are OPENSSL and mbedtls. Others more targeted to specific platforms or languages exist. It is important to realize that the library interfaces differ significantly between libraries.

Libraries do not support all known crypto algorithms. Before deciding on a library, it is important to look at their supported crypto algorithms and the roadmap for future support. Apart from availability, the library footprint, and the required execution cycles should be investigated beforehand.

The handling of certificates usually includes the checking of a certificate chain. In some libraries, chains are constructed and verified on the basis of a set of certificates, the trust anchor (usually self signed root CA), and the target certificate. In other libraries, the chain must be constructed beforehand and obey order criteria. Verification always includes the checking of the signatures. Less frequent is the checking the validity of the dates or checking the existence of a revoked certificate in the chain against a set of revoked certificates. Checking the chain on the consistency of the certificate extensions which specify the use of the certificate usually needs to be programmed explicitly.

A libary can be used to construct a (D)TLS connection. It is useful to realize that differences beetween (D)TLS implementations will occur due to the differences in the certicate checks supported by the library. On top of that, checks between client and server certificates enforced by (D)TLS are not always helpful for a BRSKI implementation. For example, the certificates of Pledge and Registrar are usually not related when the BRSKI protocol is started. It must be verified that checks on the relation between client and server certificates do not hamper a succeful DTLS connection establishment.

## OpensSSL

from openssl's apps/verify.c

INSERT_CODE_FROM_FILE examples/openssl-verify.c END


## mbedTLS


~~~~
    mbedtls_x509_crt cert;
    mbedtls_x509_crt caCert;
    uint32_t         certVerifyResultFlags;
    ...
    int result = mbedtls_x509_crt_verify(&cert, &caCert, NULL, NULL,
                                 &certVerifyResultFlags, NULL, NULL);
~~~~

## wolfSSL

To be added (TBD).


#Constrained BRSKI-EST messages

This section extends the examples from Appendix A of {{I-D.ietf-ace-coap-est}} with the constrained BRSKI requests. The CoAP headers are only worked out for the enrollstatus example.

##enrollstatus {#es}

A coaps enrollstatus message can be :

~~~
    POST coaps://192.0.2.1:8085/b/es
~~~

The corresponding CoAP header fields are shown below.

~~~
  Ver = 1
  T = 0 (CON)
  Code = 0x02 (0.02 is POST)
  Options
   Option  (Uri-Path)
     Option Delta = 0xb   (option nr = 11)
     Option Length = 0x1
     Option Value = "b"
   Option  (Uri-Path)
     Option Delta = 0x0   (option nr = 11)
     Option Length = 0x2
     Option Value = "es"
   Option  (Content-Format)
     Option Delta = 0x1   (option nr = 12)
     Option Length = 0x1
     Option Value = 60    (application/cbor)
  Payload Marker = 0xFF
  Payload = <binary CBOR enrollstatus document>
~~~

The Uri-Host and Uri-Port Options are omitted because they coincide with the transport protocol destination address and port respectively.
TBD - Show the binary CBOR payload of this example.

A 2.04 Changed response from the Registrar will then be:

~~~
   2.04 Changed
~~~

With CoAP fields:

~~~
   Ver=1
   T=2 (ACK)
   Code = 0x44 (2.04 Changed)
~~~

##voucher_status

A coaps voucher_status message can be:

~~~~
   POST coaps://[2001:db8::2:1]:61616/b/vs
     Content-Format: 60 (application/cbor)
     Payload =
INSERT_TEXT_FROM_FILE examples/voucher-status.hex END
~~~~

The request payload above is binary CBOR but represented here in hexadecimal for readability. Below is the equivalent CBOR diagnostic format.

~~~~
INSERT_TEXT_FROM_FILE examples/voucher-statusdiag.txt END
~~~~

A 2.04 Changed response without payload will then be sent by the Registrar back to the Pledge.

~~~~
   2.04 Changed
~~~~

# COSE examples {#cosesign}

These examples are generated on a Pi 4 and a PC running BASH. Keys and Certificates have been generated with openssl with the following shell script:

INSERT_FIG_FROM_FILE examples/brski-cert.sh END

The xxxx-comb certificates have been generated as required by libcoap for the DTLS connection generation.

## Pledge, Registrar and MASA keys

This first section documents the public and private keys used in the
subsequent test vectors below.  These keys come from test code and are not used in any
production system, and should only be used only to validate implementations.

### Pledge private key

INSERT_FIG_FROM_FILE examples/pledge-key.txt END

### Registrar private key {#jrcpriv}

INSERT_FIG_FROM_FILE examples/registrar-key.txt END

### MASA private key {#masapriv}

INSERT_FIG_FROM_FILE examples/masa-key.txt END

## Pledge, Registrar and MASA certificates

Below the certificates that accompany the keys. The certificate description is followed by the hexadecimal DER of the certificate

### Pledge IDevID certificate

INSERT_FIG_FROM_FILE examples/pledge-cert.txt END

This is the hexadecimal representation in (request-)voucher examples referred to as pledge-cert-hex.

INSERT_FIG_FROM_FILE examples/pledge-cert.hex END

### Registrar Certificate

INSERT_FIG_FROM_FILE examples/registrar-cert.txt END

This the hexadecimal representation, in (request-)voucher examples referred to as regis-cert-hex

INSERT_FIG_FROM_FILE examples/registrar-cert.hex END

### MASA Certificate

INSERT_FIG_FROM_FILE examples/masa-cert.txt END

This is the hexadecimal representation, in (request-)voucher examples referred to as masa-cert-hex.

INSERT_FIG_FROM_FILE examples/masa-cert.hex END


## COSE signed voucher request from Pledge to Registrar

In this example the voucher request has been signed by the Pledge, and has been sent to the JRC over CoAPS.
The Pledge uses the proximity assertion together with an included proximity-registrar-cert field to inform
MASA about its proximity to the specific Registrar.

~~~
    POST coaps://registrar.example.com/b/rv
    (Content-Format: application/voucher-cose+cbor)
    signed_request_voucher
~~~

The payload signed_request_voucher is shown as hexadecimal dump (with lf added):

INSERT_CODE_FROM_FILE examples/pledge-to-regis.txt END

The representiation of signed_voucher_request in CBOR diagnostic format is:

INSERT_CODE_FROM_FILE examples/pledge-to-regisdiag.txt END


## COSE signed voucher request from Registrar to MASA

TBD - modify example to use full paths to MASA, not short-names.
Also not use CoAP but HTTP protocol.

In this example the voucher request has been signed by the JRC using the private key from
{{jrcpriv}}.  Contained within this voucher request is the voucher
request from the Pledge to JRC.


~~~
    POST coaps://masa.example.com/b/rv
    (Content-Format: application/voucher-cose+cbor)
    signed_masa_request_voucher
~~~


The payload signed_masa_voucher_request is shown as hexadecimal dump (with lf added):

INSERT_CODE_FROM_FILE examples/regis-to-MASA.txt END

The representiation of signed_masa_voucher_request in CBOR diagnostic format is:

INSERT_CODE_FROM_FILE examples/regis-to-MASAdiag.txt END

## COSE signed voucher from MASA to Pledge via Registrar

The resulting voucher is created by the MASA and returned via the JRC to the
Pledge.  It is signed by the MASA's private key {{masapriv}} and can be
verified by the Pledge using the MASA's public key contained within the MASA certificate.

This is the raw binary signed_voucher, encoded in hexadecimal (with lf added):

INSERT_FIG_FROM_FILE examples/voucher-from-MASA.txt END

The representiation of signed_voucher in CBOR diagnostic format is:

INSERT_FIG_FROM_FILE examples/voucher-from-MASAdiag.txt END
