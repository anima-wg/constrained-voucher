---
title: Constrained Bootstrapping Remote Secure Key Infrastructure (BRSKI)
abbrev: Constrained BRSKI
docname: draft-ietf-anima-constrained-voucher-19

stand_alone: true

ipr: trust200902
area: Internet
wg: anima Working Group
kw: Internet-Draft
cat: std
consensus: true
updates: 8366, 8995

pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:

- ins: M. Richardson
  name: Michael Richardson
  org: Sandelman Software Works
  email: mcr+ietf@sandelman.ca

- ins: P. van der Stok
  name: Peter van der Stok
  org: vanderstok consultancy
  email: stokcons@bbhmail.nl

- ins: P. Kampanakis
  name: Panos Kampanakis
  org: Cisco Systems
  email: pkampana@cisco.com

- ins: E. Dijk
  name: Esko Dijk
  org: IoTconsultancy.nl
  email: esko.dijk@iotconsultancy.nl


normative:
#  RFC2119:
  RFC3688:
  RFC4193:
  RFC4210:
  RFC5280:
  RFC5652:
  RFC6020:
  RFC6066:
  RFC6347:
  RFC7250:
  RFC7950:
  RFC8366:
  RFC8446:
  RFC8610:
  RFC8949:
  RFC8995:
  RFC9031: minimal-security
  RFC9032:
  RFC9052:
  RFC9147:
  RFC9148:
  RFC9254:
  I-D.ietf-core-sid:  
  I-D.ietf-cose-x509:
  I-D.ietf-uta-rfc6125bis:
  ieee802-1AR:
    target: "http://standards.ieee.org/findstds/standard/802.1AR-2009.html"
    title: "IEEE 802.1AR Secure Device Identifier"
    author:
      ins: "IEEE Standard"
    date: 2009

informative:
  RFC4443:
  RFC6282:
  RFC6690:
  RFC7030:
  RFC7228:
  RFC8340: yang-tree
  RFC8990:
  RFC9053:
  I-D.ietf-6lo-mesh-link-establishment:
  I-D.kuehlewind-update-tag:
  I-D.richardson-anima-masa-considerations:
  I-D.ietf-anima-constrained-join-proxy:
  I-D.ietf-lake-edhoc: EDHOC
  I-D.ietf-anima-jws-voucher:
  COSE-registry:
    title: "CBOR Object Signing and Encryption (COSE) registry"
    target: "https://www.iana.org/assignments/cose/cose.xhtml"
    author:
      ins: "IANA"
    date: 2017
  Thread:
    title: "Thread support page, White Papers"
    target: "https://www.threadgroup.org/support#Whitepapers"
    author:
      ins: "Thread Group, Inc."
    date: "accessed 2022-11-28"

venue:
  mail: anima@ietf.org
  github: anima-wg/constrained-voucher

--- abstract

This document defines the Constrained Bootstrapping Remote Secure Key Infrastructure (Constrained BRSKI) protocol,
which provides a solution for secure zero-touch bootstrapping of resource-constrained (IoT) devices into the network
of a domain owner. This protocol is designed for constrained networks, which may have limited data throughput or may
experience frequent packet loss. Constrained BRSKI is a variant of the BRSKI protocol, which uses an artifact signed by the
device manufacturer called the "voucher" which enables a new device and the owner's network to mutually authenticate.
While the BRSKI voucher is typically encoded in JSON, Constrained BRSKI defines a compact CBOR-encoded voucher.
The BRSKI voucher is extended with new data types that allow for smaller voucher sizes.
The Enrollment over Secure Transport (EST) protocol, used in BRSKI, is replaced with EST-over-CoAPS;
and HTTPS used in BRSKI is replaced with CoAPS.
This document Updates RFC 8366 and RFC 8995.

--- middle

# Introduction

Secure enrollment of new nodes into constrained networks with constrained nodes presents unique challenges.
As explained in {{RFC7228}}, the networks are challenged and the nodes are constrained by energy, memory space, and code size.

The Bootstrapping Remote Secure Key Infrastructure (BRSKI) protocol described in {{RFC8995}}
provides a solution for secure zero-touch (automated) bootstrap of new (unconfigured) devices.
In it, new devices, such as IoT devices, are called "pledges", and equipped with a factory-installed Initial Device Identifier (IDevID) (see {{ieee802-1AR}}), are enrolled into a network.

The BRSKI solution described in {{RFC8995}} was designed to be modular, and this document describes a version scaled to the constraints of IoT deployments.

Therefore, this document defines a constrained version of the voucher artifact (described in {{RFC8366}}), along with a constrained version of BRSKI.
This constrained-BRSKI protocol makes use of the constrained CoAP-based version of EST (EST-coaps from {{RFC9148}}) rather than the EST over HTTPS {{RFC7030}}.
Constrained-BRSKI is itself scalable to multiple resource levels through the definition of optional functions. {{appendix-pledge-profiles}} illustrates this.

In BRSKI, the {{RFC8366}} voucher is by default serialized to JSON with a signature in CMS {{RFC5652}}.
This document defines a new voucher serialization to CBOR {{RFC8949}} with a signature in COSE {{RFC9052}}.

This COSE-signed CBOR-encoded voucher is transported using both secured CoAP and HTTPS.
The CoAP connection (between Pledge and Registrar) is to be protected by either OSCORE+EDHOC {{-EDHOC}} or DTLS (CoAPS).
The HTTP connection (between Registrar and MASA) is to be protected using TLS (HTTPS).

This document specifies a constrained voucher-request artifact based on {{Section 3 of RFC8995}}, and
voucher(-request) transport over CoAP based on {{Section 3 of RFC8995}} and on {{RFC9148}}.

The CBOR definitions for the constrained voucher format are defined using the mechanism described in {{RFC9254}} using the SID mechanism explained in {{I-D.ietf-core-sid}}.
As the tooling to convert YANG documents into a list of SID keys is still in its infancy, the table of SID values presented here MUST be considered normative rather than the output of the tool specified in {{I-D.ietf-core-sid}}.

# Terminology          {#Terminology}

The following terms are defined in {{RFC8366}}, and are used identically as in that document:
artifact, domain, imprint, Join Registrar/Coordinator (JRC), Manufacturer Authorized Signing Authority
(MASA), Pledge, Registrar, Trust of First Use (TOFU), and Voucher.

The following terms from {{RFC8995}} are used identically as in that document:
Domain CA, enrollment, IDevID, Join Proxy, LDevID, manufacturer, nonced, nonceless, PKIX.

The term Pledge Voucher Request, or acronym PVR, is introduced to refer to the voucher request between the Pledge and the Registrar.

The term Registrar Voucher Request, or acronym RVR, is introduced to refer to the voucher request between the Registrar and the MASA.

This document uses the term "PKIX Certificate" to refer to the X.509v3 profile described in {{RFC5280}}.

In code examples, the string "\<CODE BEGINS\>" denotes the start of a code example and "\<CODE ENDS\>" the end of the code example.
Four dots ("....") in a CBOR diagnostic notation byte string denotes a further sequence of bytes that is not shown for brevity.

# Requirements Language {#reqlang}

{::boilerplate bcp14}

# Overview of Protocol {#survey}

{{RFC8366}} defines a voucher that can assert proximity, authenticates the Registrar, and can offer varying levels of anti-replay protection.
The proximity proof provided by a voucher is an assertion that the Pledge and the Registrar are believed to be close together, from a network topology point of view.
Similar to BRSKI {{RFC8995}}, proximity is proven by making a DTLS connection between a Pledge and a Registrar. 
The Pledge initiates this connection using a link-local source address.

The secure DTLS connection is then used by the Pledge to make a Pledge Voucher Request (PVR). The Registrar then includes the PVR into its own 
Registrar Voucher Request (RVR), sent to an agent (MASA) of the Pledge's manufacturer. The MASA verifies the PVR and RVR and issues a signed voucher.
The voucher provides an authorization statement from the manufacturer indicating that the Registrar is the intended owner of the Pledge.
The voucher refers to the Registrar through pinning of the Registrar's identity.

After verification of the voucher, the Pledge enrolls into the Registrar's domain by obtaining a certificate using the EST-coaps {{RFC9148}} protocol, suitable for 
constrained devices. Once the Pledge has obtained its domain identity (LDevID) in this manner, it can use this identity to obtain network access credentials,  
to join the local IP network. The method to obtain such credentials depends on the particular network technology used and is outside the scope of this document. 

This document does not make any extensions to the semantic meaning of vouchers, only the encoding has been changed to optimize for constrained devices and networks.

The two main parts of the BRSKI protocol are named separately in this document: BRSKI-EST for the protocol between Pledge and Registrar, and BRSKI-MASA for the
protocol between the Registrar and the MASA.

Time-based vouchers are supported in this definition, but given that constrained devices are extremely unlikely to have accurate time, their use will be uncommon.
Most Pledges using constrained vouchers will be online during enrollment and will use live nonces to provide anti-replay protection rather than expiry times.

{{RFC8366}} defines the voucher artifact, while the Voucher Request artifact was defined in {{RFC8995}}.
This document defines both a constrained voucher and a constrained voucher-request.
They are presented in the order "voucher-request", followed by a "voucher" response as this is
the order that they occur in the protocol.

The constrained voucher request MUST be signed by the Pledge.
It signs using the private key associated with its IDevID certificate. This also holds for the most constrained types of Pledges that 
are unable to perform certain PKIX operations (such as certificate chain validation). These types of Pledge still contain an IDevID 
identity that is used for authentication. See {{rpk-considerations}} for additional details on PKIX-less operations.

The constrained voucher MUST be signed by the MASA.

For the constrained voucher request (PVR) this document defines two distinct methods for the Pledge to identify the Registrar: using either the 
Registrar's full PKIX certificate, or using a Raw Public Key (RPK). The method depends on which type of Registrar identity is 
obtained by the Pledge during the DTLS handshake process. Normally, the Pledge obtains the PKIX certificate. But when operating PKIX-less 
as described in {{rpk-considerations}}, the Registrar's RPK is obtained.

For the constrained voucher also both methods are supported to indicate (pin) a trusted domain identity: using either a pinned domain PKIX certificate, 
or a pinned RPK.

The BRSKI architectures mandates that the MASA be aware of the capabilities of the Pledge.
This is not a drawback as a Pledges is constructed by a manufacturer which also arranges for the MASA to be aware of the inventory of devices.
The MASA therefore knows if the Pledge supports PKIX operations, or if it is limited to Raw Public Key (RPK) operations only.
Based upon this, the MASA can select which attributes to use in the voucher for certain operations, like the pinning of the Registrar identity.


# Updates to RFC8366 and RFC8995

This section details the ways in which this document updates other RFCs.
The terminology for Updates is taken from {{I-D.kuehlewind-update-tag}}.

This document Updates {{RFC8366}}. It Extends {{RFC8366}} by creating a new serialization format, and creates a mechanism to pin a Raw Public Key (RPK).

This document Updates {{RFC8995}}. It Amends {{RFC8995}}

* by clarifying how pinning is done,

* adopts clearer explanation of the TLS Server Name Indicator (SNI), see {{sni}} and {{sni-masa}},

* clarifies when new trust anchors should be retrieved ({{brski-est-extensions-pledge}}),

* clarifies what kinds of Extended Key Usage attributes are appropriate for each certificate ({{registrar-certificate-requirement}}).

It Extends {{RFC8995}} as follows:

* defines the CoAP version of the BRSKI protocol,

* makes some messages optional if the results can be inferred from other validations ({{brski-est-extensions}}),

* provides the option to return trust anchors in a simpler format ({{brski-est-extensions-registrar}}),

* extends the BRSKI-MASA protocol to carry the new voucher-cose+cbor format.



# BRSKI-EST Protocol {#brski-est}

This section describes the constrained BRSKI extensions to EST-coaps {{RFC9148}} to transport the voucher between Registrar and Pledge (optionally via a Join Proxy) over CoAP.
The extensions are targeting low-resource networks with small packets.

The constrained BRSKI-EST protocol described in this section is between the Pledge and the Registrar only.

## DTLS Connection {#brski-est-dtls}

A DTLS connection is established between the Pledge and the Registrar, similar to the TLS connection
described in {{Section 5.1 of RFC8995}}. This may occur via a Join Proxy as described in {{joinproxy}}.
Regardless of the Join Proxy presence or particular mechanism used, the DTLS connection should operate identically.
The Constrained BRSKI and EST-coaps requests and responses for bootstrapping are carried over this DTLS connection.

### DTLS Version {#dtls-version}

DTLS version 1.3 {{RFC9147}} SHOULD be used in any implementation of this specification. An exception case where DTLS 1.2 {{RFC6347}} MAY 
be used is in a Pledge that uses a software platform where DTLS 1.3 is not available (yet). This may occur for example if a legacy 
device gets software-upgraded to support Constrained BRSKI. For this reason, a Registrar MUST by default support both DTLS 1.3 and DTLS 1.2 
client connections. However, for security reasons the Registrar MAY be administratively configured to support only a particular DTLS version or higher.

An EST-coaps server {{RFC9148}} that implements this specification also MUST support both DTLS 1.3 and DTLS 1.2 client connections by default.
However, for security reasons the EST-coaps server MAY be administratively configured to support only a particular DTLS version or higher.

### TLS Client Certificates: IDevID authentication

As described in {{Section 5.1 of RFC8995}}, the Pledge makes a connection to the Registrar using a TLS Client Certificate for authentication.
This is the Pledge's IDevID certificate. 

Subsequently the Pledge will send a Pledge Voucher Request (PVR). Further elements of Pledge authentication may be present in the PVR, 
as detailed in {{VR-COSE}}.

### DTLS Handshake Fragmentation Considerations {#dtls-fragments}

DTLS includes a mechanism to fragment handshake messages. This is described in {{Section 4.4 of RFC9147}}.
Constrained BRSKI will often be used with a Join Proxy, described in {{I-D.ietf-anima-constrained-join-proxy}}, which relays each DTLS message to the Registrar.
A stateless Join Proxy will need some additional space to wrap each DTLS message inside a CoAP request, while the wrapped result needs to fit in the maximum packet 
sized guaranteed on 6LoWPAN networks, which is 1280 bytes.

For this reason it is RECOMMENDED that a PMTU of 1024 bytes be assumed for the DTLS handshake and appropriate DTLS fragmentation is used.
It is unlikely that any Packet Too Big indications {{RFC4443}} will be relayed by the Join Proxy back to the Pledge.

During the operation of the constrained BRSKI-EST protocol, the CoAP Blockwise transfer mechanism will be used when message sizes exceed the PMTU.
A Pledge/EST-client on a constrained network MUST use the (D)TLS maximum fragment length extension ("max_fragment_length") defined in Section 4 of {{RFC6066}} with the maximum fragment length set to a value of either 2^9 or 2^10.


### Registrar and the Server Name Indicator (SNI) {#sni}
The SNI issue described below affects {{RFC8995}} as well, and is reported in errata: https://www.rfc-editor.org/errata/eid6648

As the Registrar is discovered by IP address, and typically connected via a Join Proxy, the name of the Registrar is not known to the Pledge.
The Pledge will not know what the hostname for the Registrar is, so it cannot do DNS-ID validation ({{I-D.ietf-uta-rfc6125bis}}) on the Registrar's certificate.
Instead, it must do validation using the voucher.

As the Pledge does not know the name of the Registrar, the Pledge cannot put any reasonable value into the {{RFC6066}} Server Name Indicator (SNI).
Threfore the Pledge SHOULD omit the SNI extension as per {{Section 9.2 of RFC8446}}.

In some cases, particularly while testing BRSKI, a Pledge may be given the hostname of a particular Registrar to connect to directly.
Such a bypass of the discovery process may result in the Pledge taking a different code branch to establish a DTLS connection, and may result in the SNI being inserted by a library.
The Registrar MUST ignore any SNI seen.

A primary motivation for making the SNI ubiquitous in the public web is because it allows for multi-tenant hosting of HTTPS sites on a single (scarce) IPv4 address.
This consideration does not apply to the server function in the Registrar because:

* it uses DTLS and CoAP, not HTTPS

* it typically uses IPv6, often {{RFC4193}} Unique Local Address, which are plentiful

* the server port number is typically discovered, so multiple tenants can be accomodated via unique port numbers.

As per {{Section 3.6.1 of RFC7030}}, the Registrar certificate MUST have the Extended Key Usage (EKU) id-kp-cmcRA.
This certificate is also used as a TLS Server Certificate, so it MUST also have the EKU id-kp-serverAuth.
See {{cosesign-registrar-cert}} for an example of a Registrar certificate with these EKUs set.


## Resource Discovery, URIs and Content Formats {#resource-discovery}

To keep the protocol messages small the EST-coaps and constrained-BRSKI URIs are shorter than the respective EST and BRSKI URIs.

The EST-coaps server URIs differ from the EST URIs by replacing the scheme https by coaps and by specifying shorter resource path names. Below are some examples;
the first two using a discovered short path name and the last one using the well-known URI of EST which requires no resource discovery by the EST client.

~~~~
  coaps://estserver.example.com/est/<short-name>
  coaps://estserver.example.com/e/<short-name>
  coaps://estserver.example.com/.well-known/est/<short-name>
~~~~

Similarly the constrained BRSKI Registrar URIs differ from the RFC 8995 BRSKI URIs by replacing the scheme https by coaps and by specifying shorter resource path names. Below are some examples;
the first two are using a discovered short path name and the last one is using the well-known URI prefix which requires no resource discovery by the Pledge.
This is the same "/.well-known/brski" prefix as defined in {{Section 5 of RFC8995}}.

~~~~
  coaps://registrar.example.com/brski/<short-name>
  coaps://registrar.example.com/b/<short-name>
  coaps://registrar.example.com/.well-known/brski/<short-name>
~~~~

Figure 5 in {{Section 3.2.2 of RFC7030}} enumerates the operations supported by EST, for which Table 1 in {{Section 5.1 of RFC9148}} enumerates the corresponding
EST-coaps short path names. Similarly, {{brski-short-uri}} below provides the mapping from the supported BRSKI extension URI paths to the constrained-BRSKI URI paths.

| BRSKI resource | constrained-BRSKI resource |
| /requestvoucher| /rv |
| /voucher_status | /vs |
| /enrollstatus | /es  |
{: #brski-short-uri title='BRSKI URI paths mapping to Constrained BRSKI URI paths'}

Note that /requestvoucher occurs between the Pledge and Registrar (in scope of the BRSKI-EST protocol), but it also occurs between Registrar and MASA. However,
as described in {{brski-est}}, this section and above table addresses only the BRSKI-EST protocol.

Pledges that wish to discover the available BRSKI bootstrap options/formats, or reduce the size of the CoAP headers by eliminating the "/.well-known/brski" path, can do a discovery 
operation using {{Section 4 of RFC6690}} by sending a discovery query to the Registrar over the secured DTLS connection.

For example, if the Registrar supports a short BRSKI URL (/b) and supports the voucher format "application/voucher-cose+cbor" (836), and status reporting in both CBOR and JSON formats, 
a CoAP resource discovery request and response may look as follows:

~~~~
  REQ: GET /.well-known/core?rt=brski*

  RES: 2.05 Content
  Content-Format: 40
  Payload:
  </b>;rt=brski,
  </b/rv>;rt=brski.rv;ct=836,
  </b/vs>;rt=brski.vs;ct="50 60",
  </b/es>;rt=brski.es;ct="50 60"
~~~~

The Registrar is under no obligation to provide shorter URLs, and MAY respond to this query with only the "/.well-known/brski/\<short-name\>" resources for the short names as defined in 
{{brski-short-uri}}.

When responding to a discovery request for BRSKI resources, the Registrar MAY in addition return
the full resource paths and the content types which are supported by these resources as shown in above example.
This is useful when multiple content types are specified for a particular resource on the Registrar.

Registrars that have implemented shorter URLs MUST also respond in equivalent ways to the corresponding "/.well-known/brski/\<short-name\>" URLs, and MUST NOT distinguish between them.
In particular, a Pledge MAY use the longer (e.g. well-known) and shorter URLs in any combination.

In case the client queries for only rt=brski type resources, the Registrar responds with only the root path for the BRSKI resources (rt=brski, resource /b in above example) and no others.
(So, a query for rt=brski, without the wildcard character.) This is shown in the below example. The Pledge requests only the BRSKI root resource of type rt=brski to check if short names 
are supported or not. In this case, the Pledge is not interested to check what voucher request formats, or status telemetry formats -- other than the mandatory default formats -- are 
supported. The compact response then shows that the Registrar indeed supports a short-name BRSKI resource at /b:

~~~~
  REQ: GET /.well-known/core?rt=brski

  RES: 2.05 Content
  Content-Format: 40
  Payload:
  </b>;rt=brski
~~~~

In above example, the well-known resource present under /.well-known/brski is not returned because this is assumed to be well-known to the Pledge and would not require discovery anyway. 
Effectively, the client is guided to preferably use the short names under resource /b instead.

Without discovery, a Pledge can only use the longer well-known URI for its voucher request, such as:

~~~~
  REQ: GET /.well-known/brski/rv
~~~~

while with discovery of shorter URLs, a request such as:

~~~~
  REQ: GET /b/rv
~~~~

is possible.

The return of multiple content-types in the "ct" attribute allows the Pledge to choose the most appropriate one for a particular operation, and allows extension with new voucher (request) formats.
Note that only Content-Format 836 ("application/voucher-cose+cbor") is defined in this document for the voucher request resource (/rv).

Content-Format 836 MUST be supported by the Registrar for the /rv resource.
If the "ct" attribute is not indicated for the /rv resource in the link format description, this implies that at least format 836 is supported.

Note that this specification allows for voucher-cose+cbor format requests and vouchers to be transmitted over HTTPS, as well as for voucher-cms+json and other formats yet to be defined over CoAP.
The burden for this flexibility is placed upon the Registrar.
A Pledge on constrained hardware is expected to support a single format only.

The Pledge and MASA need to support one or more formats (at least format 836) for the voucher and for the voucher request.
The MASA needs to support all formats that the Pledge supports.

{{discovery-considerations}} details how the Pledge discovers the Registrar and Join Proxy in different deployment scenarios.

### RFC8995 Telemetry Returns {#telemetry}

{{RFC8995}} defines two telemetry returns from the Pledge which are sent to the Registrar.
These are the BRSKI Status Telemetry {{RFC8995, Section 5.7}} and the Enrollment Status Telemetry {{RFC8995, Section 5.9.4}}.
These are two POST operations made the by Pledge at two key steps in the process.

{{RFC8995}} defines the content of these POST operations in CDDL, which are serialized as JSON.
This document extends the list of acceptable formats to CBOR as well as JSON, using the rules from {{RFC8610}}.

The existing JSON format is described as CoAP Content-Format 50 ("application/json"), and it MAY be supported.
The new CBOR format described as CoAP Content-Format 60 ("application/cbor"), MUST be supported by the Registrar for both the /vs and /es resources.

## Join Proxy options {#joinproxy}

{{I-D.ietf-anima-constrained-join-proxy}} specifies the details for a stateful and stateless constrained Join Proxy which is equivalent to {{RFC8995, Section 4}}.

## Extensions to BRSKI {#brski-extensions}

The following section explains extension within the BRSKI/CoAP connection itself.
{{discovery}} explains ways in which a pledge may discover the capability to use constrained vouchers, and to use the CoAPS transport.

### CoAP EST Resource Discovery and BRSKI {#brski-extensions-discovery}

Once the Pledge discovers an IP address and port number that connects to the Registrar (probably via a Join Proxy), and it establishes a DTLS connection.

No further discovery of hosts or port numbers is required, but a pledge that can do more than one kind of enrollment (future work offers protocols other than {{RFC9148}}), then a pledge may need to use CoAP Discovery to determine what other protocols are available.

A Pledge that only supports the EST-coaps enrollment method SHOULD NOT use CoAP discovery for BRSKI/EST resources.
It is more efficient to just try the supported enrollment method via the well-known BRSKI/EST-coaps resources.
This also avoids the Pledge having to do any CoRE Link Format parsing, which is specified in {{RFC9148, Section 4.1}}.

The Registrar MUST support all of the EST resources at their default ".well-known" locations (on the specified port)
as well as any server-specific shorter form that might also be supported.

However, if discovery is done by the Pledge, it is possible for the Registrar to return references to resources which are on different port numbers.
The Registrar SHOULD NOT use different ports numbers by default, because a Pledge that is connected via a Join Proxy can only access a single UDP port.

A Pledge that receives different port numbers or names SHOULD ignore those port numbers and continue to use the DTLS connection that it has already created.
Or it MAY fail the entire transaction and look for another Join Proxy/Registrar to do onboarding with. (If the resources without the port numbers do not work, then the Pledge will fail anyway)

A Registrar configured to never use Join Proxies MAY be configured to use multiple port numbers.
Therefore a Registrar MUST host all discoverable BRSKI resources on the same (UDP) server port that the Pledge's DTLS connection is using.
However, using the same UDP server port for all resources allows the Pledge to continue via the  same DTLS connection which is more efficient.

### CoAP responses {#brski-coap-responses}

{{RFC8995, Section 5}} defines a number of HTTP response codes that the Registrar is to return when certain conditions occur.

The 401, 403, 404, 406 and 415 response codes map directly to CoAP codes 4.01, 4.03, 4.04, 4.06 and 4.15.

The 202 Retry process which occurs in the voucher request, is to be handled in the same way as {{Section 5.7 of RFC9148}} process for Delayed Responses.


## Extensions to EST-coaps {#brski-est-extensions}

This document extends {{RFC9148}}, and it inherits the functions described in that document:
specifically, the mandatory Simple (Re-)Enrollment (/sen and /sren) and Certification Authority certificates request (/crts).
Support for CSR Attributes Request (/att) and server-side key generation (/skg, /skc) remains optional for the EST server.

Collecting the resource definitions from both {{RFC8995}}, {{RFC7030}}, and {{RFC9148}} results in the following shorter forms of URI paths
for the commonly used resources:

<!-- Table order is currently the order in which typically the resources are used by Pledge. Change if we want to -->

|-|-|-|
| BRSKI + EST      | Constrained-BRSKI + EST | Well-known URI namespace |
| /requestvoucher  | /rv     | brski  |
| /voucher_status  | /vs     | brski  |
| /csrattrs        | /att    | est    |
| /simpleenroll    | /sen    | est    |
| /cacerts         | /crts   | est    |
| /enrollstatus    | /es     | brski  |
| /simplereenroll  | /sren   | est    |
{: #brski-est-short-uri title='BRSKI/EST URI paths mapping to Constrained BRSKI/EST short URI paths'}

### Pledge Extensions {#brski-est-extensions-pledge}

This section defines extensions to the BRSKI Pledge, which are applicable during the BRSKI bootstrap procedure.
A Pledge which only supports the EST-coaps enrollment method, SHOULD NOT use discovery for EST-coaps resources, because it is more efficient to enroll (e.g. /sen) via the well-known EST resource on the current DTLS connection.
This avoids an additional round-trip of packets and avoids the Pledge having to unnecessarily implement CoRE Link Format parsing.

A constrained Pledge SHOULD NOT perform the optional EST "CSR attributes request" (/att) to minimize network traffic. The Pledge selects which attributes to include in the CSR.

One or more Subject Distinguished Name fields MUST be included.
If the Pledge has no specific information on what attributes/fields are desired in the CSR, it MUST use the Subject Distinguished Name fields from its IDevID unmodified.
The Pledge can receive such information via the voucher (encoded in a vendor-specific way) or via some other, out-of-band means.

A constrained Pledge MAY use the following optimized EST-coaps procedure to minimize network traffic.

1. if the voucher, that validates the current Registrar, contains a single pinned domain CA certificate, the Pledge provisionally considers this certificate as the EST trust anchor, as if it were the result of "CA certificates request" (/crts) to the Registrar.

2. Using this CA certificate as trust anchor it proceeds with EST simple enrollment (/sen) to obtain its provisionally trusted LDevID certificate.

3. If the Pledge validates that the trust anchor CA was used to sign its LDevID certificate, the Pledge accepts the pinned domain CA certificate as the legitimate trust anchor CA for the Registrar's domain and accepts the associated LDevID certificate.

4. If the trust anchor CA was NOT used to sign its LDevID certificate, the Pledge MUST perform an actual "CA certificates request" (/crts) to the EST server to obtain the EST CA trust anchor(s) since these can differ from the (temporary) pinned domain CA.

5. When doing this /crts request, the Pledge MAY use a CoAP Accept Option with value 287 ("application/pkix-cert") to limit the number of returned EST CA trust anchors to only one.
A constrained Pledge MAY support only this format in a /crts response, per {{Section 5.3 of RFC9148}}.

7. If the Pledge cannot obtain the single CA certificate or the finally validated CA certificate cannot be chained to the LDevID certificate, then the Pledge MUST abort the enrollment process and report the error using the enrollment status telemetry (/es).

Note that even though the Pledge may avoid performing any /crts request using the above EST-coaps procedure during bootstrap, it SHOULD support retrieval of the trust anchor CA periodically as detailed in the next section.


### EST-client Extensions {#brski-est-extensions-estclient}

This section defines extensions to EST-coaps clients, used after the BRSKI bootstrap procedure is completed.
(Note that such client is not called "Pledge" in this section, since it is already enrolled into the domain.)
A constrained EST-coaps client MAY support only the Content-Format 287 ("application/pkix-cert") in a /crts response, per {{Section 5.3 of RFC9148}}.
In this case, it can only store one trust anchor of the domain.

An EST-coaps client that has an idea of the current time (internally, or via NTP) SHOULD consider the validity time of the trust anchor CA, and MAY begin requesting a new trust anchor CA using the /crts request when the CA has 50% of it's validity time (notAfter - notBefore) left.
A client without access to the current time cannot decide if the trust anchor CA has expired, and SHOULD poll periodically for a new trust anchor using the /crts request at an interval of approximately 1 month.
An EST-coaps server SHOULD include the CoAP ETag Option in every response to a /crts request, to enable clients to perform low-overhead validation whether their trust anchor CA is still valid.
The EST-coaps client SHOULD store the ETag resulting from a /crts response in memory and SHOULD use this value in an ETag Option in its next GET /crts request.

The above-mentioned limitation that an EST-coaps client may support only one trust anchor CA is not an issue in case the domain trust anchor remains stable. However, special consideration is
needed for cases where the domain trust anchor can change over time. Such a change may happen due to relocation of the client device to a new domain, or due to key update of
the trust anchor as described in {{RFC4210, Section 4.4}}.

From the client's viewpoint, a trust anchor change typically happens during EST re-enrollment: a change of domain CA requires all devices
operating under the old domain CA to acquire a new LDevID issued by the new domain CA. A client's re-enrollment may be triggered by various events, such as an instruction to re-enroll sent by a domain entity, or an imminent expiry of its LDevID certificate.
How the re-enrollment is explicitly triggered on the client by a domain entity, such as a commissioner or a Registrar, is out of scope of this specification.

The mechanism described in {{RFC4210, Section 4.4}} for Root CA key update requires four certificates: OldWithOld, OldWithNew, NewWithOld, and NewWithNew. The OldWithOld certificate is already
stored in the EST client's trust store. The NewWithNew certificate will be distributed as the single certificate in a /crts response, during EST re-enrollment.
Since the EST client can only accept a single certificate in a /crts response it implies that the EST client
cannot obtain the certificates OldWithNew and NewWithOld in this way, to perform the complete verification of the new domain CA. Instead, the client only verifies the EST-coaps server using its
old domain CA certificate in its trust store as detailed below, and based on this trust in the active and valid DTLS connection it automatically trusts the
new (NewWithNew) domain CA certificate that the EST-coaps server provides in the /crts response.

In this manner, even during rollover of trust anchors, it is possible to have only a single trust anchor provided in a /crts response.

During the period of the certificate renewal, it is not possible to create new communication channels between devices with NewCA certificates devices with OldCA certificates.
One option is that devices should avoid restarting existing DTLS or OSCORE connections during this interval that new certificates are being deployed.
The recommended period for certificate renewal is 24 hours.
For re-enrollment, the constrained EST-coaps client MUST support the following EST-coaps procedure, where optional re-enrollment to a new domain is under control of the EST-coaps server:

1. The client connects with DTLS to the EST-coaps server, and authenticates with its present domain certificate (LDevID certificate) as usual. The EST-coaps server authenticates itself with its domain certificate that
is trusted by the client, i.e. it chains to the single trust anchor that the client has stored. This is the "old" trust anchor, the one that will be eventually replaced in case the server 
decides to re-enroll the client into a new domain. The client also checks that the server is a Registration Authority (RA) of the domain as required by {{Section 3.6.1 of RFC7030}}. 

2. The client performs the simple re-enrollment request (/sren) and upon success it obtains a new LDevID.

3. The client verifies the new LDevID against its (single) existing domain trust anchor. If it chains successfully, this means the trust anchor did not change and the client MAY skip retrieving the current CA certificate using the "CA certificates request" (/crts). If it does not chain successfully, this means the trust anchor was changed/updated and the client then MUST retrieve the new domain trust anchor using the "CA certificates request" (/crts).

4. If the client retrieved a new trust anchor in step 3, then it MUST verify that the new trust anchor chains with the new LDevID certificate it obtained in step 2. If it chains successfully, the client stores both, accepts the new LDevID certificate and stops using it prior LDevID certificate. If it does not chain successfully, the client MUST NOT update its LDevID certificate, it MUST NOT update its (single) domain trust anchor, and the client MUST abort the enrollment process and MUST attempt to report the error to the EST-coaps server using enrollment status telemetry (/es).

Note that even though the EST-coaps client may skip the /crts request in step 3, it SHOULD support retrieval of the trust anchor CA periodically as detailed earlier in this section.

Note that an EST-coaps server that is also a Registrar will already support the enrollment status telemetry resource (/es) in step 4, while an EST-coaps server that purely implements {{RFC9148}}, and not the present specification, will not support this resource.

### Registrar Extensions {#brski-est-extensions-registrar}

A Registrar SHOULD host any discoverable EST-coaps resources on the same (UDP) server port that the Pledge's DTLS initial connection is using.
This avoids the overhead of the Pledge reconnecting using DTLS, when it performs EST enrollment after the BRSKI voucher request.

The Content-Format 50 (application/json) MUST be supported and 60 (application/cbor) MUST be supported by the Registrar for the /vs and /es resources.

Content-Format 836 MUST be supported by the Registrar for the /rv resource.

When a Registrar receives a "CA certificates request" (/crts) request with a CoAP Accept Option with value 287 ("application/pkix-cert") it SHOULD return only the
single CA certificate that is the envisioned or actual authority for the current, authenticated Pledge making the request.

If the Pledge included in its request an Accept Option for only the 287 ("application/pkix-cert") Content Format, but the domain has been configured to operate with multiple CA trust anchors only, then the Registrar returns a 4.06 Not Acceptable error to signal that the Pledge needs to use the Content Format 281 ("application/pkcs7-mime; smime-type=certs-only") to retrieve all the certificates.

If the current authenticated client is an EST-coaps client that was already enrolled in the domain, and the Registrar is configured to assign this client to a new domain CA trust anchor during the next EST re-enrollment procedure, then the Registrar MUST respond with the new domain CA certificate in case the client performs the "CA Certificates request" (/crts) with an Accept Option for 287 only. This signals the client that a new domain is assigned to it. The client follows the procedure as defined in {{brski-est-extensions-estclient}}.


# BRSKI-MASA Protocol {#brski-masa}

This section describes extensions to and clarifications of the BRSKI-MASA protocol between Registrar and MASA.

## Protocol and Formats {#brski-masa-protocol-format}

{{Section 5.4 of RFC8995}} describes a connection between the Registrar and the MASA as being a normal TLS connection using HTTPS.
This document does not change that. The Registrar MUST use the format "application/voucher-cose+cbor" in its voucher request to MASA, when the Pledge uses this format in its request to the Registrar {{RFC8995}}.

The MASA only needs to support formats for which it has constructed Pledges that use that format.

The Registrar MUST use the same format for the RVR as the Pledge used for its PVR.

The Registrar indicates the voucher format it wants to receive from MASA using the HTTP Accept header.
This format MUST be the same as the format of the PVR, so that the Pledge can parse it.

At the moment of writing the creation of coaps based MASAs is deemed unrealistic.
The use of CoAP for the BRSKI-MASA connection can be the subject of another document.
Some consideration was made to specify CoAP support for consistency, but:

* the Registrar is not expected to be so constrained that it cannot support HTTPS client connections.

* the technology and experience to build Internet-scale HTTPS responders (which the MASA is) is common, while the experience doing the same for CoAP is much less common.

* a Registrar is likely to provide onboarding services to both constrained and non-constrained devices.  Such a Registrar would need to speak HTTPS anyway.

* a manufacturer is likely to offer both constrained and non-constrained devices, so there may in practice be no situation in which the MASA could be CoAP-only.  Additionally, as the MASA is intended to be a function that can easily be oursourced to a third-party service provider, reducing the complexity would also seem to reduce the cost of that function.

* security-related considerations: see {{security-masa-coaps}}.

## Registrar Voucher Request {#brski-masa-rvr}

If the PVR contains a proximity assertion, the Registrar MUST propagate this assertion into the RVR by including the "assertion" field with the value "proximity".
This conforms to the example in {{Section 3.3 of RFC8995}} of carrying the assertion forward.

## MASA and the Server Name Indicator (SNI) {#sni-masa}

A TLS/HTTPS connection is established between the Registrar and MASA.

{{Section 5.4 of RFC8995}} explains this process, and there are no externally visible changes.
A MASA that supports the unconstrained voucher formats should be able to support constrained voucher formats equally well.

There is no requirement that a single MASA be used for both constrained and unconstrained voucher requests: the choice of MASA is determined by the id-mod-MASAURLExtn2016 extension contained in the IDevID.

The Registrar MUST do DNS-ID checks ({{I-D.ietf-uta-rfc6125bis}}) on the contents of the certificate provided by the MASA.

In constrast to the Pledge/Registrar situation, the Registrar always knows the name of the MASA, and MUST always include an {{RFC6066}} Server Name Indicator.
The SNI is optional in TLS1.2, but common.
The SNI it considered mandatory with TLS1.3.

The presence of the SNI is needed by the MASA, in order for the MASA's server to host multiple tenants (for different customers).

The Registrar SHOULD use a TLS Client Certificate to authenticate to the MASA per {{Section 5.4.1 of RFC8995}}.
If the certificate that the Registrar uses is marked as a id-kp-cmcRA certificate, via Extended Key Usage, then it MUST also have the id-kp-clientAuth EKU attribute set.

### Registrar Certificate Requirement {#registrar-certificate-requirement}

In summary for typical Registrar use, where a single Registrar certificate is used, then the certificate MUST have EKU of: id-kp-cmcRA, id-kp-serverAuth, id-kp-clientAuth.

<!-- ******************************************************************** -->

# Pinning in Voucher Artifacts {#pinning}

The voucher is a statement by the MASA for use by the Pledge that provides the identity of the Pledge's owner.
This section describes how the owner's identity is determined and how it is specified within the voucher.

## Registrar Identity Selection and Encoding {#registrar-identity}

{{Section 5.5 of RFC8995}} describes BRSKI policies for selection of the owner identity. It indicates some of the flexibility that is possible for the Registrar, and recommends the Registrar to include only certificates in the voucher request (CMS) signing structure that participate in the certificate chain that is to be pinned.

The MASA is expected to evaluate the certificates included by the Registrar in its voucher request, forming them into a chain with the Registrar's (signing) identity on one end. Then, it pins a certificate selected from the chain.
For instance, for a domain with a two-level certification authority (see {{fig-twoca}}), where the voucher-request has been signed by "Registrar", its signing structure includes two additional CA certificates.
The arrows in the figure indicate the issuing of a certificate, i.e. author of (1) issued (2) and author of (2) issued (3).

~~~~
{::include two-ca-chain.txt}
~~~~
{: #fig-twoca title='Two-Level CA PKI'}

When the Registrar is using a COSE-signed constrained voucher request towards MASA, instead of a regular CMS-signed voucher request, the COSE_Sign1 object contains a protected and an unprotected header.
The Registrar MUST place all the certificates needed to validate the signature chain from the Registrar on the RVR in an "x5bag" attribute in the unprotected header {{I-D.ietf-cose-x509}}.

The "x5bag" attribute is very important as it provides the required signals from the Registrar to control what identity is pinned in the resulting voucher.
This is explained in the next section.

## MASA Pinning Policy {#masa-pinning-policy}

The MASA, having assembled and verified the chain in the signing structure of the voucher request needs to select a certificate to pin.
(For the case that only the Registrar's End-Entity certificate is included, only this certificate can be selected and this section does not apply.)
The BRSKI policy for pinning by the MASA as described in {{Section 5.5.2 of RFC8995}} leaves much flexibility to the manufacturer.

The present document adds the following rules to the MASA pinning policy to reduce the network load:

1. for a voucher containing a nonce, it SHOULD select the most specific (lowest-level) CA certificate in the chain.
2. for a nonceless voucher, it SHOULD select the least-specific (highest-level) CA certificate in the chain that is allowed under the MASA's policy for this specific domain.

The rationale for 1. is that in case of a voucher with nonce, the voucher is valid only in scope of the present DTLS connection between Pledge and Registrar anyway, so there is no
benefit to pin a higher-level CA. By pinning the most specific CA the constrained Pledge can validate its DTLS connection using less crypto operations. The
rationale for pinning a CA instead of the Registrar's End-Entity certificate directly is based on the following benefit on constrained networks: the pinned certificate in the voucher
can in common cases be re-used as a Domain CA trust anchor during the EST enrollment and during the operational phase that follows after EST enrollment, as explained in {{brski-est-extensions-pledge}}.

The rationale for 2. follows from the flexible BRSKI trust model for, and purpose of, nonceless vouchers (Sections 5.5.* and 7.4.1 of {{RFC8995}}).

Refering to {{fig-twoca}} of a domain with a two-level certification authority, the most specific CA ("Sub-CA") is the identity that is pinned by MASA in a nonced voucher.
A Registrar that wished to have only the Registrar's End-Entity certificate pinned would omit the "domain CA" and "Sub-CA" certificates from the voucher-request.

In case of a nonceless voucher, depending on the trust level, the MASA pins the "Registrar" certificate (low trust in customer), or the "Sub-CA" certificate (in case of
medium trust, implying that any Registrar of that sub-domain is acceptable), or even the "domain CA" certificate (in case of high trust in the customer, and possibly a pre-agreed need of the
customer to obtain flexible long-lived vouchers).

## Pinning of Raw Public Keys {#pinned-with-rpk}

Specifically for constrained use cases, the pinning of the raw public key (RPK) of the Registrar is also supported in the constrained voucher, instead of a PKIX certificate.
If an RPK is pinned it MUST be the RPK of the Registrar.

When the Pledge is known by MASA to support RPK but not PKIX certificate operations, the voucher produced by the MASA pins the RPK of the Registrar in either the "pinned-domain-pubk"
or "pinned-domain-pubk-sha256" field of a voucher.
This is described in more detail in {{yang-voucher}} and {{rpk-considerations}}. A Pledge that does not support PKIX certificates cannot use EST to enroll; it has to use
another method for enrollment without certificates and the Registrar has to support this method also.
It is possible that the Pledge will not enroll, but instead only a network join operation will occur (See {{RFC9031}}).
How the Pledge discovers this method and details of the enrollment method are out of scope of this document.

When the Pledge is known by MASA to support PKIX format certificates, the "pinned-domain-cert" field present in a voucher typically pins a domain certificate.
That can be either the End-Entity certificate of the Registrar, or the certificate of a domain CA of the Registrar's domain as specified in {{masa-pinning-policy}}.
However, if the Pledge is known to also support RPK pinning and the MASA intends to identify the Registrar in the voucher (not the CA), then MASA MUST pin the RPK (RPK3 in {{fig-pinning}}) of the Registrar instead of the Registrar's End-Entity certificate to save space in the voucher.

~~~~
{::include pinning-options.txt}
~~~~
{: #fig-pinning title='Raw Public Key (RPK) pinning'}

## Considerations for use of IDevID-Issuer {#registrar-idevid-issuer}

{{RFC8366}} and {{RFC8995}} defines the idevid-issuer attribute for voucher and voucher-request (respectively), but they summarily explain when to use it.

The use of idevid-issuer is provided so that the serial-number to which the issued voucher pertains can be relative to the entity that issued the devices' IDevID.
In most cases there is a one to one relationship between the trust anchor that signs vouchers (and is trusted by the pledge), and the Certification Authority that signs the IDevID.
In that case, the serial-number in the voucher must refer to the same device as the serial-number that is in IDevID certificate.

However, there situations where the one to one relationship may be broken.
This occurs whenever a manufacturer has a common MASA, but different products (on different assembly lines) are produced with identical serial numbers.
A system of serial numbers which is just a simple counter is a good example of this.
A system of serial numbers where there is some prefix relating the product type does not fit into this, even if the lower digits are a counter.

It is not possible for the Pledge or the Registrar to know which situation applies.
The question to be answered is whether or not to include the idevid-issuer in the PVR and the RVR.
A second question arisews as to what the format of the idevid-issuer contents are.

Analysis of the situation shows that the pledge never needs to include the idevid-issuer in it's PVR, because the pledge's IDevID certificate is available to the Registrar, and the Authority Key Identifier is contained within that.
The pledge therefore has no need to repeat this.

For the RVR, the Registrar has to examine the pledge's IDevID certificate to discover the serial number for the Registrar's Voucher Request (RVR).
This is clear in {{Section 5.5 of RFC8995}}.
That section also clarifies that the idevid-issuer is to be included in the RVR.

Concerning the Authority Key Identifier, {{RFC8366}} specifies that the entire object i.e. the extnValue OCTET STRING is to be included: comprising the AuthorityKeyIdentifier, SEQUENCE, Choice as well as the OCTET STRING that is the keyIdentifier.

# Artifacts

This section describes for both the voucher request and
the voucher first the abstract (tree) definition as explained
in {{-yang-tree}}.  This provides a high-level
view of the contents of each artifact.

Then the assigned SID values are presented. These have been assigned using
the rules in {{I-D.ietf-core-sid}}.

## Voucher Request artifact {#voucher-request-artifact}

### Tree Diagram

The following diagram is largely a duplicate of the contents of {{RFC8366}},
with the addition of the fields proximity-registrar-pubk, proximity-registrar-pubk-sha256,
proximity-registrar-cert, and prior-signed-voucher-request.

prior-signed-voucher-request is only used between the Registrar and the MASA.
proximity-registrar-pubk or proximity-registrar-pubk-sha256 optionally replaces proximity-registrar-cert
for the most constrained cases where RPK is used by the Pledge.

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained-tree.txt END

### SID values {#request-sid-values}

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained-sid.txt END

The "assertion" attribute is an enumerated type {{RFC8366}}, and the current PYANG tooling does not document the valid values for this attribute.
In the JSON serialization, the literal strings from the enumerated types are used so there is no ambiguity.
In the CBOR serialization, a small integer is used.
This following values are documented here, but the YANG module should be considered authoritative. No IANA registry is provided or necessary because the YANG module provides for extensions.

Integer  | Assertion Type
|-|-|
0        | verified
1        | logged
2        | proximity
{: #assertion-enums title='CBOR integers for the "assertion" attribute enum'}

### YANG Module {#yang-voucher-request}

In the voucher-request-constrained YANG module, the voucher is "augmented" within the "used" grouping statement such that one continuous set of SID values is generated for the voucher-request-constrained module name, all voucher attributes, and the voucher-request-constrained attributes. Two attributes of the voucher are "refined" to be optional.

INSERT_FIG_FROM_FILE ietf-voucher-request-constrained@DATE.yang END

### Example Pledge voucher request (PVR) artifact {#example-pvr}

Below, an example constrained voucher request (PVR) from a Pledge to a Registrar is shown in CBOR diagnostic notation. 
Long CBOR byte strings have been shortened (with "....") for readability. The enum value of the assertion field is calculated 
to be 2 for the "proximity" assertion by following the algorithm described in section 9.6.4.2 of {{RFC7950}}. For reference, {{request-sid-values}} shows a 
table with all currently defined assertion values.

INSERT_FIG_FROM_FILE examples/voucher-request-example1.txt END

The Pledge has included the item proximity-registrar-pubk which carries the public key of the Registrar, instead of including the full Registrar certificate in 
a proximity-registrar-cert item. This is done to reduce the size of the PVR. Also note that the Pledge did not include the created-on field since it lacks an 
internal real-time clock and has no knowledge of the current time at the moment of performing the bootstrapping.

### Example Registrar voucher request (RVR) artifact {#example-rvr}

Next, an example constrained voucher request (RVR) from a Registrar to a MASA is shown in CBOR diagnostic notation. 
The Registrar has created this request triggered by the reception of the Pledge voucher request (PVR) of the previous example. 
Again, long CBOR byte strings have been shortened for readability.

INSERT_FIG_FROM_FILE examples/voucher-request-example2.txt END

Note that the Registrar uses here the string data type for all key names, instead of the more compact SID integer keys. This is fine for any use cases where the 
network between Registrar and MASA is an unconstrained network where data size is not critical. The constrained voucher request format supports both the 
string and SID key types.


## Voucher artifact

The voucher's primary purpose is to securely assign a Pledge to an
owner.  The voucher informs the Pledge which entity it should
consider to be its owner.

### Tree Diagram

The following diagram is largely a duplicate of the contents of {{RFC8366}},
with only the addition of the fields pinned-domain-pubk and pinned-domain-pubk-sha256.

INSERT_FIG_FROM_FILE ietf-voucher-constrained-tree.txt END

### SID values

INSERT_FIG_FROM_FILE ietf-voucher-constrained-sid.txt END

The "assertion" enumerated attribute is numbered as per {{request-sid-values}}.

### YANG Module {#yang-voucher}

In the voucher-constrained YANG module, the voucher is "augmented" within the "used" grouping statement such that one continuous set of SID values is generated for the voucher-constrained module name, all voucher attributes, and the voucher-constrained attributes.
Two attributes of the voucher are "refined" to be optional.

INSERT_FIG_FROM_FILE ietf-voucher-constrained@DATE.yang END

### Example voucher artifacts {#example-voucher}

Below, an example constrained voucher is shown in CBOR diagnostic notation. It was created by a MASA in response to  
receiving the Registrar Voucher Request (RVR) shown in {{example-rvr}}. The enum value of the assertion field is set to 2, 
to acknowledge to both the Pledge and the Registrar that the proximity of the Pledge to the Registrar is considered proven. 

INSERT_FIG_FROM_FILE examples/voucher-example1.txt END

While the above example voucher includes the nonce from the PVR, the next example is a nonce-less voucher. Instead of a nonce, it 
includes an expires-on field with the date and time on which the voucher expires. Because the MASA did not verify the proximity of 
the Pledge and Registrar in this case, the assertion field contains a weaker assertion of "verified" (0). This indicates that the 
MASA verified the domain's ownership of the Pledge via some other means. The enum value of the assertion field for "verified" is 
calculated to be 0 by following the algorithm described in section 9.6.4.2 of {{RFC7950}}.

INSERT_FIG_FROM_FILE examples/voucher-example2.txt END

The voucher is valid for one week. To verify the voucher's validity, the Pledge would either need an internal real-time clock 
or some external means of obtaining the current time, such as Network Time Protocol (NTP) or a radio time signal receiver. 


## Signing voucher and voucher-request artifacts with COSE {#VR-COSE}

The COSE_Sign1 structure is discussed in {{Section 4.2 of RFC9052}}.
The CBOR object that carries the body, the signature, and the information about the body  and signature is called the COSE_Sign1 structure.
It is used when only one signature is used on the body.

Support for ECDSA with SHA2-256 using curve secp256r1 (aka prime256k1) is RECOMMENDED.
Most current low power hardware has support for acceleration of this algorithm.
Future hardware designs could omit this in favour of a newer algorithms.
This is the ES256 keytype from Table 1 of {{RFC9053}}.
Support for curve secp256k1 is OPTIONAL.

Support for EdDSA using Curve 25519 is RECOMMENDED in new designs if hardware support is available.
This is keytype EDDSA (-8) from Table 2 of {{RFC9053}}.  A "crv" parameter is necessary to specify the Curve, which from Table 18.  The 'kty' field MUST be present, and it MUST be 'OKP'. (Table 17)

A transition towards EdDSA is occurring in the industry.
Some hardware can accelerate only some algorithms with specific curves, other hardware can accelerate any curve, and still other kinds of hardware provide a tool kit for acceleration of any eliptic curve algorithm.

In general, the Pledge is expected to support only a single algorithm, while the Registrar, usually not constrained, is expected to support a wide variety of algorithms: both legacy ones and up-and-coming ones via regular software updates.

An example of the supported COSE_Sign1 object structure containing a Pledge Voucher Request (PVR) is shown in {{fig-cose}}.

~~~~
18(                  / tag for COSE_Sign1                       /
  [
    h'A10126',       / protected COSE header encoding: {1: -7}  /
                     /            which means { "alg": ES256 }  /
    {},              / unprotected COSE header parameters       /
    h'A119....3839', / voucher-request binary content (in CBOR) /
    h'4567....1234'  / voucher-request binary Sign1 signature   /
  ]
)
~~~~
{: #fig-cose title='COSE_Sign1 PVR example in CBOR diagnostic notation' align="left"}

The {{COSE-registry}} specifies the integers/encoding for the "alg" field in {{fig-cose}}. The "alg"
field restricts the key usage for verification of this COSE object to a particular cryptographic algorithm.

### Signing of Registrar Voucher Request (RVR)

A Registrar MUST include a COSE "x5bag" structure in the RVR as explained in {{registrar-identity}}.
{{fig-cose-rvr}} shows an example Registrar Voucher Request (RVR) that includes the x5bag as an unprotected 
header parameter (32). The bag contains two certificates in this case.

~~~~
18(                  / tag for COSE_Sign1                       /
  [
    h'A10126',       / protected COSE header encoding: {1: -7}  /
                     /            which means { "alg": ES256 }  /
    {
      32: [h'308202....9420AE', h'308201....E08CFF']  / x5bag   /
    },              
    h'A178....7FED', / voucher-request binary content (in CBOR) /
    h'E1B7....2925'  / voucher-request binary Sign1 signature   /
  ]
)
~~~~
{: #fig-cose-rvr title='COSE_Sign1 RVR example in CBOR diagnostic notation' align="left"}

A "kid" (key ID) field is optionally present in the unprotected COSE header parameters map of a COSE object. 
If present, it identifies the public key of the key pair that was used to sign the 
COSE message. The value of the key identifier "kid" parameter may be in any format agreed between signer and verifier.
Usually a hash of the public key is used to identify the public key; but the choice of key identifier method is
vendor-specific. If "kid" is not present, then a verifying party needs to use other context information to
retrieve the right public key to verify the COSE_Sign1 object against. 

By default, a Registrar does not include a "kid" parameter in the RVR since the signing key
is already identified by the signing certificates included in the COSE "x5bag" structure.
A Registrar nevertheless MAY use a "kid" parameter in its RVR to identify its signing key/identity.

The method of generating such "kid" value is vendor-specific and SHOULD be configurable in the Registrar to
support commonly used methods. In order to support future business cases and supply chain integrations, 
a Registrar using the "kid" field MUST be configurable, on a per-manufacturer basis, 
to select a particular method for generating the "kid" value such that it is compatible with the method that 
the manufacturer. Both binary and string values MUST be supported per {{RFC9052}}, respectively encoded 
in the "kid" field using a CBOR byte string (bstr) or text string (tstr).

### Signing of Pledge Voucher Request (PVR)

Like in the RVR, a "kid" (key ID) field is also optionally present in the PVR. It can be used to identify the signing key/identity to 
the MASA. 

A Pledge by default SHOULD NOT use a "kid" parameter in its PVR, because its signing key is already identified
by the Pledge's unique serial number that is included in the PVR and (by the Registrar) in the RVR. This achieves the smallest possible 
PVR data size while still enabling the MASA to verify the PVR. 
Still, when required the Pledge MAY use a "kid" parameter in its PVR to help the MASA identify the right public key to verify against. This can occur
for example if a Pledge has multiple IDevID identities. The "kid" parameter in this case may be a simple integer identifying one out of N identities 
present, or it may be a hash of the public key, or anything else the Pledge vendor decides.
A Registrar normally SHOULD ignore a "kid" parameter used in a received PVR, as this information is intended for the MASA.
In other words, there is no need for the Registrar to verify the contents of this field, but it may include it in an audit log.

The example in {{fig-cose-pvr-kid}} shows a PVR with the "kid" parameter present.

~~~~
18(                  / tag for COSE_Sign1                       /
  [
    h'A10126',       / protected COSE header encoding: {1: -7}  /
                     /            which means { "alg": ES256 }  /
    {
       4: h'59AB3E'  / COSE "kid" header parameter              /
    },
    h'A119....3839', / voucher-request binary content (in CBOR) /
    h'5678....7890'  / voucher-request binary Sign1 signature   /
  ]
)
~~~~
{: #fig-cose-pvr-kid title='COSE_Sign1 PVR example with "kid" field present' align="left"}


The Pledge SHOULD NOT use the "x5bag" structure in the PVR.  A
Registrar that processes a PVR with an "x5bag" structure MUST ignore
it, and MUST use only the TLS Client Certificate extension for
authentication of the Pledge.

A situation where the Pledge MAY use the x5bag structure is for communication
of certificate chains to the MASA.  This would arise in some vendor-
specific situations involving outsourcing of MASA functionality, or
rekeying of the IDevID certification authority.

In {{cosesign}} further examples of signed PVRs are shown.

### Signing of voucher by MASA

The MASA SHOULD NOT use a "kid" parameter in the voucher response, because the MASA's signing 
key is already known to the Pledge. Still, where needed the MASA MAY use
a "kid" parameter in the voucher response to help the Pledge identify the right MASA public key 
to verify against. This can occur for example if a Pledge has multiple IDevID identities.

The MASA SHOULD NOT include an x5bag attribute in the voucher response - the exception is if the MASA knows 
that the Pledge doesn't pre-store the signing public key and certificate, and thus the MASA needs to provide 
a cert or cert chain that will enable linking the signing identity to the pre-stored Trust Anchor (CA) in the Pledge.
This approach is not recommended, because including certificates in the x5bag attribute will significantly increase the size of the voucher 
which impacts operations on constrained networks.

If the MASA signing key is based upon a PKI (see {{I-D.richardson-anima-masa-considerations}} Section 2.3), and the Pledge 
only pre-stores a manufacturer (root) CA identity in its Trust Store which is not the identity that signs the voucher, 
then a certificate chain needs to be included with the voucher in order for the Pledge to validate the MASA signing CA's signature 
by validating the chain up to the CA in its Trust Store.

In BRSKI CMS signed vouchers {{RFC8995}}, the CMS structure has a place for such certificates.
In the COSE-signed constrained vouchers described in this document, the x5bag attribute {{I-D.ietf-cose-x509}} is used to contain the needed certificates to form the chain.
A Registrar MUST NOT remove the x5bag attribute from the unprotected COSE header parameters when sending the voucher back to the Pledge.

In {{fig-cose-voucher}} an example is shown of a COSE-signed voucher. This example shows the common case where the "x5bag" attribute is not used.

~~~~
18(                  / tag for COSE_Sign1                       /
  [
    h'A10126',       / protected COSE header encoding: {1: -7}  /
                     /            which means { "alg": ES256 }  /
    {},              / unprotected COSE header parameters       /
    h'A119....3839', / voucher binary content (in CBOR)         /
    h'2A2C....7FBF'  / voucher binary Sign1 signature by MASA   /
  ]
)
~~~~
{: #fig-cose-voucher title='COSE_Sign1 signed voucher in CBOR diagnostic notation' align="left"}



# Extensions to Discovery {#discovery}

It is assumed that a Join Proxy as defined in {{I-D.ietf-anima-constrained-join-proxy}} seamlessly provides a (relayed) DTLS connection between the Pledge and the Registrar. 
To use a Join Proxy, a Pledge needs to discover it. For Pledge discovery of a Join Proxy, this section extends Section 4.1 of {{RFC8995}} for the constrained BRSKI case.

In general, the Pledge may be one or more hops away from the Registrar, where one hop means the Registrar is a direct link-local neighbor of the Pledge.
The case of one hop away can be considered as a degenerate case, because a Join Proxy is not really needed then. 

The degenerate case would be unusual in constrained wireless network deployments, because a Registrar would typically not have a wireless network interface of the type used for constrained devices. Rather, it would have a high-speed network interface.
Nevertheless, the situation where the Registrar is one hop away from the Pledge could occur in various cases like wired IoT networks or in wireless constrained networks where the Pledge is in radio range of a 6LoWPAN Border Router (6LBR) and the 6LBR happens to host a Registrar.

In order to support the degenerate case, the Registrar SHOULD announce itself as if it were a Join Proxy -- though it would actually announce its real (stateful) Registrar CoAPS endpoint.
No actual Join Proxy functionality is then required on the Registrar.

So, a Pledge only needs to discover a Join Proxy, regardless of whether it is one or more than one hop away from a relevant Registrar. It first discovers the link-local address and the join-port of a Join Proxy. The Pledge then follows the constrained BRSKI procedure of initiating a DTLS connection using the link-local address and join-port of the Join Proxy.

Once enrolled, a Pledge itself may function as a Join Proxy.
The decision whether or not to provide this functionality depends upon many factors and is out of scope for this document.
Such a decision might depend upon the amount of energy available to the device, the network bandwidth available, as well CPU and memory availability.

The process by which a Pledge discovers the Join Proxy, and how a Join Proxy discovers the location of the Registrar, are the subject of the remainder of this section. 
Further details on both these topics are provided in {{I-D.ietf-anima-constrained-join-proxy}}.

## Discovery operations by Pledge

The Pledge must discover the address/port and protocol with which to communicate. The present document only defines coaps (CoAP over DTLS) as a protocol.

Note that the identifying the format of the voucher-request and the voucher is not a required part of the Pledge's discovery operation.
It is assumed that all Registrars support all relevant voucher(-request) formats, while the Pledge only supports a single format.
A Pledge that makes a voucher request to a Registrar that does not support that format will receive a CoAP 4.06 Not Acceptable status code and the bootstrap attempt will fail.

### GRASP discovery {#grasppledgediscovery}

This section is normative for uses with an ANIMA ACP.
In the context of autonomic networks, the Join-Proxy uses the DULL GRASP M_FLOOD mechanism to announce itself.
Section 4.1.1 of {{RFC8995}} discusses this in more detail.

The following changes are necessary with respect to figure 10 of {{RFC8995}}:

* The transport-proto is IPPROTO_UDP
* the objective is AN_Proxy

The Registrar announces itself using ACP instance of GRASP using M_FLOOD messages.
Autonomic Network Join Proxies MUST support GRASP discovery of Registrar as described in section 4.3 of {{RFC8995}} .

Here is an example M_FLOOD announcing the Join-Proxy at fe80::1, on standard coaps port 5684, using DTLS.

~~~
     [M_FLOOD, 12340815, h'fe800000000000000000000000000001', 180000,
     [["AN_Proxy", 4, 1, "DTLS"],
     [O_IPv6_LOCATOR,
     h'fe800000000000000000000000000001', IPPROTO_UDP, 5684]]]
~~~
{: #fig-grasp-rg title='Example of Join Proxy announcement message' align="left"}

Note that a Join Proxy that supports also supports RFC8995 onboarding using HTTPS may announce more than one objective.
Objectives with an empty objective-value (whether CBOR NULL or an empty string) refer to {{RFC8995}} defaults.

Here is an example of an announcement that offers both constrained and unconstrained onboarding:

~~~
     [M_FLOOD, 12340851, h'fe800000000000000000000000000001', 180000,
     [["AN_Proxy", 4, 1, ""],
      [O_IPv6_LOCATOR,
       h'fe800000000000000000000000000001', IPPROTO_TCP, 4443],
      ["AN_Proxy", 4, 1, "DTLS"],
      [O_IPv6_LOCATOR,
       h'fe800000000000000000000000000001', IPPROTO_UDP, 5684]]
~~~
{: #fig-grasp-duo title='Example of Join Proxy announcing two bootstrap methods' align="left"}

### CoAP Discovery
The details on CoAP discovery of a Join Proxy by a Pledge are provided in {{Section 5.2.1 of I-D.ietf-anima-constrained-join-proxy}}. 
In this section some examples of CoAP discovery interactions are given.

Below, a typical example is provided showing the Pledge's CoAP request and the Join Proxy's CoAP response. The Join Proxy responds with a link-local 
source address, which is the same address as indicated in the URI-reference element ({{RFC6690}}) in the discovery response payload. The Join 
Proxy has a dedicated port 8485 opened for DTLS connections of Pledges.

~~~~
  REQ: GET coap://[ff02::fd]/.well-known/core?rt=brski.jp

  RES: 2.05 Content
  <coaps://[fe80::c78:e3c4:58a0:a4ad]:8485>;rt=brski.jp
~~~~

The next example shows a Join Proxy that uses the default CoAPS port 5684 for DTLS connections of Pledges. In this case, the Join Proxy host 
is not using port 5684 for any other purposes.

~~~~
  REQ: GET coap://[ff02::fd]/.well-known/core?rt=brski.jp

  RES: 2.05 Content
  <coaps://[fe80::c78:e3c4:58a0:a4ad]>;rt=brski.jp
~~~~

In the following example, two Join Proxies respond to the multicast query. The Join Proxies use a slightly different CoRE Link Format 
encoding. While the first encoding is more compact, both encodings are allowed per {{RFC6690}}. The Pledge may now select one of the 
two Join Proxies for initiating its DTLS connection.

~~~~
  REQ: GET coap://[ff02::fd]/.well-known/core?rt=brski*

  RES: 2.05 Content
  <coaps://[fe80::c78:e3c4:58a0:a4ad]:8485>;rt=brski.jp

  RES: 2.05 Content
  <coaps://[fe80::d359:3813:f382:3b23]:63245>;rt="brski.jp"
~~~~



## Discovery operations by Join Proxy
The Join Proxy needs to discover a Registrar, at the moment it needs to relay data towards the Registrar or prior to that moment.

### GRASP Discovery {#graspregistrardiscovery}

This section is normative for uses with an ANIMA ACP. In the context of autonomic networks, the Registrar announces itself to a stateful Join Proxy using ACP instance of GRASP using M_FLOOD messages.
Section 4.3 of {{RFC8995}} discusses this in more detail.

The following changes are necessary with respect to figure 10 of {{RFC8995}}:

* The transport-proto is IPPROTO_UDP
* the objective is AN_join_registrar, identical to {{RFC8995}}.
* the objective name is "BRSKI_JP".

The Registrar announces itself using ACP instance of GRASP using M\_FLOOD messages.
Autonomic Network Join Proxies MUST support GRASP discovery of Registrar as described in section 4.3 of {{RFC8995}}.

Here is an example M\_FLOOD announcing the Registrar on example port 5684, which is the standard CoAPS port number.

~~~
   [M_FLOOD, 51804321, h'fda379a6f6ee00000200000064000001', 180000,
   [["AN_join_registrar", 4, 255, "BRSKI_JP"],
    [O_IPv6_LOCATOR,
     h'fda379a6f6ee00000200000064000001', IPPROTO_UDP, 5684]]]
~~~
{: #fig-grasp-rgj title='Example of Registrar announcement message' align="left"}

The Registrar uses a routable address that can be used by enrolled constrained Join Proxies.
The address will typically be a Unique Local Address (ULA) as in the example, but could also be a Global Unicast Address (GUA).

### CoAP discovery {#coap-disc}
Further details on CoAP discovery of the Registrar by a Join Proxy are provided in {{Section 5.1.1 of I-D.ietf-anima-constrained-join-proxy}}. 



# Deployment-specific Discovery Considerations {#discovery-considerations}

This section details how discovery is done in specific deployment scenarios.

## 6TSCH Deployments

In 6TISCH networks, the Constrained Join Proxy (CoJP) mechanism is described in {{RFC9031}}.
Such networks are expected to use a {{-EDHOC}} to do key management.
This is the subject of future work.
The Enhanced Beacon has been extended in {{RFC9032}} to allow for discovery of the Join Proxy.

## Generic networks using GRASP

{{RFC8995}} defines a mechanism for the Pledge to discover a Join Proxy by listening for {{RFC8990}} GRASP messages.
This mechanism can be used on any network which does not have another more specific mechanism.
This mechanism supports mesh networks, and can also be used over unencrypted WIFI.

## Generic networks using mDNS

{{RFC8995}} also defines a non-normative mechanism for the Pledge to discover a Join Proxy by doing mDNS queries.
This mechanism can be used on any network which does not have another recommended mechanism.
This mechanism does not easily support mesh networks.  It can be used over unencrypted WIFI.

## Thread networks using Mesh Link Establishment (MLE)

Thread {{Thread}} is a wireless mesh network protocol based on 6LoWPAN {{RFC6282}} and other IETF protocols. In Thread, a new device
discovers potential Thread networks and Thread routers to join by using the Mesh Link Establishment (MLE) {{I-D.ietf-6lo-mesh-link-establishment}} protocol.
MLE uses the UDP port number 19788. The new device sends discovery requests on different IEEE 802.15.4 radio channels, to which routers (if any present) respond with a discovery response containing information about
their respective network. Once a suitable router is selected the new device initiates a DTLS transport-layer secured connection to the network's commissioning application, over a link-local single radio hop to the selected
Thread router. This link is not yet secured at the radio level: link-layer security will be set up once the new device is approved by the commissioning application to join the Thread network, and it gets provisioned with
network access credentials.

The Thread router acts here as a Join Proxy. The MLE discovery response message contains UDP port information to signal the new device which port to use for its DTLS connection.


# Design Considerations

The design considerations for the CBOR encoding of vouchers are much the same as for JSON vouchers in {{RFC8366}}.
One key difference is that the names of the leaves in the YANG definition do not affect the size of the resulting CBOR, as the SID translation process assigns integers to the names.

Any POST request to the Registrar with resource /vs or /es returns a 2.04 Changed response with empty payload. The client should be aware that the server may use a piggybacked CoAP response (ACK, 2.04) but may also respond with a separate CoAP response, i.e. first an (ACK, 0.0) that is an acknowledgement of the request reception followed by a (CON, 2.04) response in a separate CoAP message.

# Raw Public Key Use Considerations {#rpk-considerations}

This section explains techniques to reduce the data volume and complexity of the BRSKI bootstrap.
The use of a raw public key (RPK) in the pinning process can significantly reduce the number of bytes sent over the wire and round trips, and reduce the code footprint in a Pledge, 
but it comes with a few significant operational limitations.

## The Registrar Trust Anchor

When the Pledge first connects to the Registrar, the connection to the Registrar is provisional, as explained in {{Section 5.6.2 of RFC8995}}.
The Registrar normally provides its public key in a TLSServerCertificate, and the Pledge uses that to validate that integrity of the (D)TLS connection, but it does not validate the identity of
the provided certificate.

As the TLSServerCertificate object is never verified directly by the Pledge, sending it can be considered superfluous.
So instead of using a (TLSServer)Certificate of type X509 (see section 4.4.2 of {{RFC8446}}),
a RawPublicKey object (as defined by {{RFC7250}}) is used.

A Registrar operating in a mixed environment can determine whether to send a Certificate or a Raw Public Key to the Pledge: this is signaled by the Pledge. In the case it needs an RPK, it 
includes the server\_certificate\_type of RawPublicKey. This is shown in section 5 of {{RFC7250}}.

The Pledge always sends a client\_certificate\_type of X509 (not an RPK), so that the Registrar can properly identify the Pledge and distill the MASA URI information from its IDevID certificate.

## The Pledge Voucher Request

The Pledge puts the Registrar's public key into the proximity-registrar-pubk field of the Pledge Voucher Request (PVR).
(The proximity-registrar-pubk-sha256 can also be used for efficiency, if the 32-bytes of a SHA256 hash turns out to be smaller than a typical ECDSA key.)

As the format of this pubk field is identical to the TLS RawPublicKey data object, no manipulation at all is needed to insert this into the PVR.

## The Voucher Response

A returned voucher will have a pinned-domain-pubk field with the identical key as was found in the proximity-registrar-pubk field above, as well as being identical to the 
Registrar's RPK in the currently active DTLS connection.

Validation of this key by the Pledge is what takes the DTLS connection out of the provisional state; see {{Section 5.6.2 of RFC8995}} for more details.

The voucher needs to be validated first by the Pledge.
The Pledge needs to have a public key to validate the signature from the MASA on the voucher.

The MASA's public key counterpart of the (private) MASA signing key MUST be already installed in the Pledge at manufacturing time. Otherwise, the Pledge 
cannot validate the voucher's signature.

# Use of constrained vouchers with HTTPS

This specification contains two extensions to {{RFC8995}}: a constrained voucher format (COSE), and a constrained transfer protocol (CoAP).

On constrained networks with constrained devices, it make senses to use both together.
However, this document does not mandate that this be the only way.

A given constrained device design and software may be re-used for multiple device models, such as a model having only an IEEE 802.15.4 radio, or a model
having only an IEEE 802.11 (Wi-Fi) radio, or a model having both these radios.
A manufacturer of such device models may wish to have code only for the use of the constrained voucher format (COSE), and use it on all supported radios
including the IEEE 802.11 radio. For this radio, the software stack to support HTTP/TLS may be already integrated into the radio module hence it is
attractive for the manufacturer to reuse this. This type of approach is supported by this document.
In the case that HTTPS is used, the regular long {{RFC8995}} resource names are used, together with the new "application/voucher-cose+cbor" media type described in this document.
For status telemetry requests, the Pledge may use either one or both of the formats defined in {{telemetry}}. A Registrar MUST support both formats. 

Other combinations are possible, but they are not enumerated here.
New work such as {{I-D.ietf-anima-jws-voucher}} provides new formats that may be useable over a number of different transports.
In general, sending larger payloads over constrained networks makes less sense,
while sending smaller payloads over unconstrained networks is perfectly acceptable.

The Pledge will in most cases support a single voucher format, which it uses without negotiation i.e. without discovery of formats supported.
The Registrar, being unconstrained, is expected to support all voucher formats.
There will be cases where a Registrar does not support a new format that a new Pledge uses, and this is an unfortunate situation that will result in lack of interoperation.

The responsability for supporting new formats is on the Registrar.

# Security Considerations {#security}

## Duplicate serial-numbers

In the absense of correct use of idevid-issuer by the Registrar as detailed in {{registrar-idevid-issuer}}, it would be possible for a malicious Registrar to use an unauthorized voucher for a device.
This would apply only to the case where a Manufacturer Authorized Signing Authority (MASA) is trusted by different products from the same manufacturer, and the manufacturer has duplicated serial numbers as a result of a merge, acquisition or mis-management.

For example, imagine the same manufacturer makes light bulbs as well as gas centrifuges,
and said manufacturer does not uniquely allocate product serial numbers.
This attack only works for nonceless vouchers.
The attacker has obtained a light bulb which happens to have the same serial-number as a gas centrofuge which it wishes to obtain access.
The attacker performs a normal BRSKI onboarding for the light bulb, but then uses the resulting voucher to onboard the gas centrofuge.
The attack requires that the gas centrofuge be returned to a state where it is willing to perform a new onboarding operation.

This attack is prevented by the mechanism of having the Registrar include the idevid-issuer in the RVR, and the MASA including it in the resulting voucher.
The idevid-issuer is not included by default: a MASA needs to be aware if there are parts of the organization which duplicates serial numbers, and if so, include it.

## IDevID security in Pledge

The security of this protocol depends upon the Pledge identifying itself to the Registrar using it's manufacturer installed certificate: the IDevID certificate.
Associated with this certificate is the IDevID private key, known only to the Pledge.
Disclosure of this private key to an attacker would permit the attacker to impersonate the Pledge towards the Registrar, probably gaining access credentials to that Registrar's network.

If the IDevID private key disclosure is known to the manufacturer, there is little recourse other than recall of the relevant part numbers.
The process for communicating this recall would be within the BRSKI-MASA protocol.
Neither this specification nor {{RFC8995}} provides for consultation of a Certification Revocation List (CRL) or Open Certificate Status Protocol (OCSP) by a Registrar when evaluating an IDevID certificate.
However, the BRSKI-MASA protocol submits the IDevID from the Registrar to the manufacturer's MASA and a manufacturer would have an opportunity to decline to issue a voucher for a device which they believe has become compromised.

It may be difficult for a manufacturer to determine when an IDevID private key has been disclosed.
Two situations present themselves: in the first situation a compromised private key might be reused in a counterfeit device, which is sold to another customer.
This would present itself as an onboarding of the same device in two different networks.
The manufacturer may become suspicious seeing two voucher requests for the same device from different Registrars.
Such activity could be indistinguishable from a device which has been resold from one operator to another, or re-deployed by an operator from one location to another.

In the second situation, an attacker having compromised the IDevID private key of a device might then install malware into the same device and attempt to return it to service.
The device, now blank, would go through a second onboarding process with the original Registrar.
Such a Registrar could notice that the device has been "factory reset" and alert the operator to this situation.
One remedy against the presence of malware is through the use of Remote Attestation such as described in {{?I-D.ietf-rats-architecture}}.
Future work will need to specify a background-check Attestation flow as part of the voucher-request/voucher-response process.
Attestation may still require access to a private key (e.g. IDevID private key) in order to sign Evidence, so a primary goal should be to keep any private key safe within the Pledge.

In larger, more expensive, systems there is budget (power, space, and bill of materials) to include more specific defenses for a private key.
For instance, this includes putting the IDevID private key in a Trusted Platform Module (TPM), or use of Trusted Execution Environments (TEE) for access to the key.
On smaller IoT devices, the cost and power budget for an extra part is often prohibitive.

It is becoming more and more common for CPUs to have an internal set of one-time fuses that can be programmed (often they are "burnt" by a laser) at the factory.
This section of memory is only accessible in some priviledged CPU state.
The use of this kind of CPU is appropriate as it provides significant resistance against key disclosure even when the device can be disassembled by an attacker.

In a number of industry verticals, there is increasing concern about counterfeit parts.
These may be look-alike parts created in a different factory, or parts which are created in the same factory during an illegal night-shift, but which are not subject to the appropriate level of quality control.
The use of a manufacturer-signed IDevID certificate provides for discovery of the pedigree of each part, and this often justifies the cost of the security measures associated with storing the private key.


## Security of CoAP and UDP protocols

{{brski-masa-protocol-format}} explains that no CoAPS version of the BRSKI-MASA protocol is proposed.
The connection from the Registrar to the MASA continues to be HTTPS as in {{RFC8995}}.
This has been done to simplify the MASA deployment for the manufacturer, because no new protocol needs to be enabled on the server.

The use of UDP protocols across the open Internet is sometimes fraught with security challenges.
Denial-of-service attacks against UDP based protocols are trivial as there is no three-way handshake as done for TCP.
The three-way handshake of TCP guarantees that the node sending the connection request is reachable using the origin IP address.
While DTLS contains an option to do a stateless challenge -- a process actually stronger than that done by TCP -- it is not yet common for this mechanism to be available in hardware at multigigabit speeds.
It is for this reason that this document defines using HTTPS for the Registrar to MASA connection.


## Registrar Certificate may be self-signed

The provisional (D)TLS connection formed by the Pledge with the Registrar does not authenticate the Registrar's identity.
This Registrar's identity is validated by the {{RFC8366}} voucher that is issued by the MASA, signed with an anchor that was built-in to the Pledge.

The Registrar may therefore use any certificate, including a self-signed one.
The only restrictions on the certificate is that it MUST have EKU bits set as detailed in {{registrar-certificate-requirement}}.

## Use of RPK alternatives to proximity-registrar-cert

In {{voucher-request-artifact}} two compact alternative fields for proximity-registrar-cert are defined that include an RPK: proximity-registrar-pubk and proximity-registrar-pubk-sha256.
The Pledge can use these fields in its PVR to identify the Registrar based on its public key only. Since the full certificate of the proximate Registrar is not included, use of these fields
by a Pledge implies that a Registrar could insert another certificate with the same public key identity into the RVR. For example, an older or a newer version of its certificate.
The MASA will not be able to detect such act by the Registrar. But since any 'other' certificate the Registrar could insert in this way still encodes its identity the additional risk
of using the RPK alternatives is neglible.

When a Registrar sees a PVR that uses one of proximity-registrar-pubk or proximity-registrar-pubk-sha256 fields, this implies the Registrar must include the certificate identified by these fields into its RVR.
Otherwise, the MASA is unable to verify proximity. This requirement is already implied by the "MUST" requirement in {{registrar-identity}}.

## MASA support of CoAPS {#security-masa-coaps}

The use of CoAP for the BRSKI-MASA connection is not in scope of the current document.
The following security considerations have led to this choice of scope:

* the technology and experience to build secure Internet-scale HTTPS responders (which the MASA is) is common, while the experience in doing the same for CoAP is much less common.

* in many enterprise networks, outgoing UDP connections are often treated as suspicious, which could effectively block CoAP connections for some firewall configurations.

* reducing the complexity of MASA (i.e. less protocols supported) would also reduce its potential attack surface, which is relevant since the MASA is 24/7 exposed on the Internet and accepting (untrusted) incoming connections.

# IANA Considerations

## GRASP Discovery Registry

IANA is asked to extend the registration of the "AN\_Proxy" (without quotes) in the "GRASP Objective Names" table in the Grasp Parameter registry.
This document should also be cited for this existing registration, because {{grasppledgediscovery}} defines the new protocol value IPPROTO_UDP for the objective.

IANA is asked to extend the registration of the "AN\_join\_registrar" (without quotes) in the "GRASP Objective Names" table in the Grasp Parameter registry.
This document should also be cited for this existing registration, because {{graspregistrardiscovery}} adds the objective value "BRSKI_JP" to the objective.

## Resource Type Registry

Additions to the sub-registry "Resource Type Link Target Attribute Values", within the "CoRE Parameters" IANA registry are specified below.

Reference: \[This RFC\]

Attribute | Description
|-|-|
brski    | Root path of Bootstrapping Remote Secure Key Infrastructure (BRSKI) resources
brski.rv | BRSKI request voucher resource
brski.vs | BRSKI voucher status telemetry resource
brski.es | BRSKI enrollment status telemetry resource
{: #iana-core-rt-values title='Resource Type (rt) link target attribute values for IANA registration'}

## The IETF XML Registry

This document registers two URIs in the IETF XML registry {{RFC3688}}.
Following the format in {{RFC3688}}, the following registration is requested:

      URI: urn:ietf:params:xml:ns:yang:ietf-voucher-constrained
      Registrant Contact: The ANIMA WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.

      URI: urn:ietf:params:xml:ns:yang:ietf-voucher-request-constrained
      Registrant Contact: The ANIMA WG of the IETF.
      XML: N/A, the requested URI is an XML namespace.

## The YANG Module Names Registry

This document registers two YANG modules in the YANG Module Names registry {{RFC6020}}.  Following the format defined in {{RFC6020}}, the the following registration is requested:

      name:         ietf-voucher-constrained
      namespace:    urn:ietf:params:xml:ns:yang:ietf-voucher-constrained
      prefix:       vch
      reference:    RFC XXXX

      name:         ietf-voucher-request-constrained
      namespace:    urn:ietf:params:xml:ns:yang:ietf-voucher-
                                               request-constrained
      prefix:       vch
      reference:    RFC XXXX

## The RFC SID range assignment sub-registry

    ------------ ------ --------------------------- ------------
    Entry-point | Size | Module name               | RFC Number
    ------------ ------ --------------------------- ------------
    2450          50     ietf-voucher-constrained    [This RFC]
    2500          50     ietf-voucher-request        [This RFC]
                                     -constrained
    ----------- ------  --------------------------- ------------

Warning: These SID values are defined in {{I-D.ietf-core-sid}}, not as an Early Allocation.

IANA: please update the names in the Registry to match these revised names, if they have not already  been revised.

## Media Types Registry

This section registers the 'application/voucher-cose+cbor' in the IANA "Media Types" registry.
This media type is used to indicate that the content is a CBOR voucher or voucher request
signed with a COSE_Sign1 structure {{RFC9052}}.

### application/voucher-cose+cbor

    Type name:  application
    Subtype name:  voucher-cose+cbor
    Required parameters:  N/A
    Optional parameters:  N/A
    Encoding considerations:  binary (CBOR)
    Security considerations:  Security Considerations of [This RFC].
    Interoperability considerations:  The format is designed to be
      broadly interoperable.
    Published specification:  [This RFC]
    Applications that use this media type:  ANIMA, 6tisch, and other
      zero-touch onboarding systems
    Fragment identifier considerations:  The syntax and semantics of
      fragment identifiers specified for application/voucher-cose+cbor
      are as specified for application/cbor.  (At publication of this
      document, there is no fragment identification syntax defined for
      application/cbor.)
    Additional information:
      Deprecated alias names for this type: N/A
      Magic number(s):  N/A
      File extension(s):  .vch
      Macintosh file type code(s):  N/A
    Person & email address to contact for further information:  IETF
      ANIMA Working Group (anima@ietf.org) or IETF Operations and
      Management Area Working Group (opsawg@ietf.org)
    Intended usage:  COMMON
    Restrictions on usage:  N/A
    Author:  ANIMA WG
    Change controller:  IETF
    Provisional registration? (standards tree only):  NO

## CoAP Content-Format Registry

IANA has allocated ID 836 from the sub-registry "CoAP Content-Formats".

    Media type                     Encoding   ID   Reference
    -----------------------------  --------- ----  ----------
    application/voucher-cose+cbor  -          836  [This RFC]

## Update to BRSKI Parameters Registry

This section updates the BRSKI Well-Known URIs sub-registry of the IANA Bootstrapping Remote Secure Key Infrastructures (BRSKI) Parameters Registry
by adding a new column "Short URI". The contents of this field MUST be specified for any newly registered URI as follows:

Short URI: A short name for the "URI" resource that can be used by a Constrained BRSKI Pledge in a CoAP request to the Registrar. In case the "URI" resource is only used between Registrar and MASA, the value "--" is registered denoting that a short name is not applicable.

The initial contents of the sub-registry including the new column are as follows:

| URI | Short URI | Description | Reference
requestvoucher | rv | Request voucher: Pledge to Registrar, and Registrar to MASA      | [RFC8995], \[This RFC\]
voucher_status | vs | Voucher status telemetry: Pledge to Registrar                    | [RFC8995], \[This RFC\]
requestauditlog| -- | Request audit log: Registrar to MASA                             | [RFC8995]
enrollstatus   | es | Enrollment status telemetry: Pledge to Registrar                 | [RFC8995], \[This RFC\]
{: #brski-wellknown-uri title='Update of the BRSKI Well-Known URI Sub-Registry'}


# Acknowledgements

<t>We are very grateful to <contact initials="J." surname="Schaad" fullname="Jim Schaad"/> for explaining COSE/CMS choices and for correcting early versions of the COSE_Sign1 objects. 
</t><t>
<contact initials="M." surname="Veillette" fullname="Michel Veillette"/> did extensive work on _pyang_ to extend it to support the SID allocation process, and this document was among its first users. 
</t><t>
<contact initials="R." surname="Housley" fullname="Russ Housley"/>, <contact initials="D." surname="Franke" fullname="Daniel Franke"/> and <contact initials="H." surname="Birkholtz" fullname="Henk Birkholtz"/> provided review feedback. 
</t><t>
The BRSKI design team has met on many Tuesdays and Thursdays for document review. The team includes: <contact initials="A." surname="Schellenbaum" fullname="Aurelio Schellenbaum"/>, <contact initials="D." surname="von Oheimb" fullname="David von Oheimb"/>, <contact initials="S." surname="Fries" fullname="Steffen Fries"/>, <contact initials="T." surname="Werner" fullname="Thomas Werner"/> and <contact initials="T." surname="Eckert" fullname="Toerless Eckert"/>.
</t>
    
# Changelog

-11 to -19
    (For change details see GitHub issues https://github.com/anima-wg/constrained-voucher/issues and related Pull Requests.)

-10
    Design considerations extended
    Examples made consistent

-08
    Examples for cose_sign1 are completed and improved.

-06
    New SID values assigned; regenerated examples

-04
    voucher and request-voucher MUST be signed
    examples for signed request are added in appendix
    IANA SID registration is updated
    SID values in examples are aligned
    signed cms examples aligned with new SIDs

-03

    Examples are inverted.

-02

    Example of requestvoucher with unsigned appllication/cbor is added
    attributes of voucher "refined" to optional
    CBOR serialization of vouchers improved
    Discovery port numbers are specified

-01

    application/json is optional, application/cbor is compulsory
    Cms and cose mediatypes are introduced

--- back

#Library Support for BRSKI {#libsup}

For the implementation of BRSKI, the use of a software library to manipulate certificates and use crypto algorithms is often beneficial. Two C-based examples are OpenSSL and mbedtls. Others more targeted to specific platforms or languages exist. It is important to realize that the library interfaces differ significantly between libraries.

Libraries do not support all known crypto algorithms. Before deciding on a library, it is important to look at their supported crypto algorithms and the roadmap for future support. Apart from availability, the library footprint, and the required execution cycles should be investigated beforehand.

The handling of certificates usually includes the checking of a certificate chain. In some libraries, chains are constructed and verified on the basis of a set of certificates, the trust anchor (usually self signed root CA), and the target certificate. In other libraries, the chain must be constructed beforehand and obey order criteria. Verification always includes the checking of the signatures. Less frequent is the checking the validity of the dates or checking the existence of a revoked certificate in the chain against a set of revoked certificates. Checking the chain on the consistency of the certificate extensions which specify the use of the certificate usually needs to be programmed explicitly.

A libary can be used to construct a (D)TLS connection. It is useful to realize that differences beetween (D)TLS implementations will occur due to the differences in the certicate checks supported by the library. On top of that, checks between client and server certificates enforced by (D)TLS are not always helpful for a BRSKI implementation. For example, the certificates of Pledge and Registrar are usually not related when the BRSKI protocol is started. It must be verified that checks on the relation between client and server certificates do not hamper a succeful DTLS connection establishment.

## OpensSSL

From openssl's apps/verify.c :

INSERT_CODE_FROM_FILE examples/openssl-verify.c END


## mbedTLS

~~~~
<CODE BEGINS>
mbedtls_x509_crt cert;
mbedtls_x509_crt caCert;
uint32_t         certVerifyResultFlags;
...
int result = mbedtls_x509_crt_verify(&cert, &caCert, NULL, NULL,
                             &certVerifyResultFlags, NULL, NULL);
<CODE ENDS>
~~~~

#Constrained BRSKI-EST Message Examples

This appendix extends the message examples from Appendix A of {{RFC9148}} with constrained BRSKI messages.
The CoAP headers are only fully worked out for the first example, enrollstatus.

##enrollstatus {#es}

A coaps enrollstatus message from Pledge to Registrar can be as follows:

~~~~
  REQ: POST coaps://192.0.2.1:8085/b/es
  Content-Format: 60
  Payload: <binary CBOR encoding of an enrollstatus map>
~~~~

The corresponding CoAP header fields for this request are shown below.

~~~
  Ver = 1
  T = 0 (CON)
  TKL = 1
  Code = 0x02 (0.02 is POST method)
  Message ID = 0xab0f
  Token = 0x4d
  Options
   Option  (Uri-Path)
     Option Delta = 0xb   (option nr = 11)
     Option Length = 0x1
     Option Value = "b"
   Option  (Uri-Path)
     Option Delta = 0x0   (option nr = 11)
     Option Length = 0x2
     Option Value = "es"
   Option  (Content-Format)
     Option Delta = 0x1   (option nr = 12)
     Option Length = 0x1
     Option Value = 60    (application/cbor)
  Payload Marker = 0xFF
  Payload = A26776657273696F6E0166737461747573F5 (18 bytes binary)
~~~

The Uri-Host and Uri-Port Options are omitted because they coincide with the transport protocol (UDP) destination address and port respectively.

The above binary CBOR enrollstatus payload looks as follows in CBOR diagnostic notation, for the case of enrollment success:

~~~
  {
    "version": 1,
    "status": true
   }
~~~

Alternatively the payload could look as follows in case of enrollment failure, using the reason field to describe the failure:

~~~
  Payload = A36776657273696F6E0166737461747573F466726561736F6E782A3C
            496E666F726D61746976652068756D616E207265616461626C652065
            72726F72206D6573736167653E    (69 bytes binary)

  {
    "version": 1,
    "status": false,
    "reason": "<Informative human readable error message>"
  }
~~~

To indicate successful reception of the enrollmentstatus telemetry report, a response from the Registrar may then be:

~~~
  2.04 Changed
~~~

Which in case of a piggybacked response has the following CoAP header fields:

~~~
  Ver=1
  T=2 (ACK)
  TKL=1
  Code = 0x44 (2.04 Changed)
  Message ID = 0xab0f
  Token = 0x4d
~~~

##voucher_status

A coaps voucher_status message from Pledge to Registrar can be as follows:

~~~~
  REQ: POST coaps://[2001:db8::2:1]/.well-known/brski/vs
  Content-Format: 60 (application/cbor)
  Payload = 
INSERT_TEXT_FROM_FILE examples/voucher-status.hex END
~~~~

The request payload above is binary CBOR but represented here in hexadecimal for readability. Below is the equivalent CBOR diagnostic format.

~~~~
INSERT_TEXT_FROM_FILE examples/voucher-statusdiag.txt END
~~~~

A success response without payload will then be sent by the Registrar back to the Pledge to indicate reception of the telemetry report:

~~~~
  2.04 Changed
~~~~


# COSE-signed Voucher (Request) Examples {#cosesign}

This appendix provides examples of COSE-signed voucher requests and vouchers. First, the used test keys and certificates are described, followed by examples of
a constrained PVR, RVR and voucher.


## Pledge, Registrar and MASA Keys

This section documents the public and private keys used for all examples in this appendix. These keys are not used in any
production system, and must only be used for testing purposes.

### Pledge IDevID private key {#pledgepriv}

INSERT_CODE_FROM_FILE examples/script-cose-examples/keys/privkey_pledge.pem END

INSERT_CODE_FROM_FILE examples/cose-examples/privkey_pledge.txt END


### Registrar private key {#jrcpriv}

INSERT_CODE_FROM_FILE examples/script-cose-examples/keys/privkey_registrar.pem END

INSERT_CODE_FROM_FILE examples/cose-examples/privkey_registrar.txt END


### MASA private key {#masapriv}

INSERT_CODE_FROM_FILE examples/script-cose-examples/keys/privkey_masa_ca.pem END

INSERT_CODE_FROM_FILE examples/cose-examples/privkey_masa_ca.txt END


## Pledge, Registrar, Domain CA and MASA Certificates

All keys and certificates used for the examples have been generated with OpenSSL - see {{appendix-gencerts}} for more details on certificate generation.
Below the certificates are listed that accompany the keys shown above. Each certificate description is followed by the hexadecimal representation of the X.509 ASN.1 DER encoded certificate.
This representation can be for example decoded using an online ASN.1 decoder.

### Pledge IDevID Certificate

INSERT_CODE_FROM_FILE examples/cose-examples/pledge.txt END

Below is the hexadecimal representation of the binary X.509 DER-encoded certificate:

INSERT_CODE_FROM_FILE examples/cose-examples/pledge.hex END

### Registrar Certificate {#cosesign-registrar-cert}

INSERT_CODE_FROM_FILE examples/cose-examples/registrar.txt END

Below is the hexadecimal representation of the binary X.509 DER-encoded certificate:

INSERT_CODE_FROM_FILE examples/cose-examples/registrar.hex END

### Domain CA Certificate {#cose-example-domain-ca-cert}

The Domain CA certificate is the CA of the customer's domain. It has signed the Registrar (RA) certificate.

INSERT_CODE_FROM_FILE examples/cose-examples/domain_ca.txt END

Below is the hexadecimal representation of the binary X.509 DER-encoded certificate:

INSERT_CODE_FROM_FILE examples/cose-examples/domain_ca.hex END

### MASA Certificate

The MASA CA certificate is the CA that signed the Pledge's IDevID certificate.

INSERT_CODE_FROM_FILE examples/cose-examples/masa_ca.txt END

Below is the hexadecimal representation of the binary X.509 DER-encoded certificate:

INSERT_CODE_FROM_FILE examples/cose-examples/masa_ca.hex END

## COSE-signed Pledge Voucher Request (PVR)

In this example, the voucher request (PVR) has been signed by the Pledge using the IDevID private key of {{pledgepriv}}, 
and has been sent to the link-local constrained Join Proxy (JP) over CoAPS to the JP's join port. The join port happens to 
use the default CoAPS UDP port 5684.

~~~
  REQ: POST coaps://[JP-link-local-address]/b/rv
  Content-Format: 836
  Payload: <signed_pvr>
~~~

When the Join Proxy receives the DTLS handshake messages from the Pledge, it will relay these messages to the Registrar. 
The payload signed_voucher_request is shown as hexadecimal dump (with lf added) below:

INSERT_CODE_FROM_FILE examples/cose-examples/pvr.hex END

The representiation of signed_pvr in CBOR diagnostic format (with lf added) is:

INSERT_CODE_FROM_FILE examples/cose-examples/pvr.txt END

The COSE payload is the PVR, encoded as a CBOR byte string. The diagnostic representation of it is shown below:

INSERT_CODE_FROM_FILE examples/cose-examples/pvr-nonsigned.txt END

The Pledge uses the "proximity" (key '1', SID key 2502, enum value 2) assertion together with an included 
proximity-registrar-pubk field (key '12', SID 2513) to inform MASA about its proximity to the specific Registrar.

## COSE-signed Registrar Voucher Request (RVR)

In this example the Registrar's voucher request has been signed by the JRC (Registrar) using the private key from
{{jrcpriv}}.  Contained within this voucher request is the voucher request PVR that was made by the Pledge to JRC.
Note that the RVR uses the HTTPS protocol (not CoAP) and corresponding long URI path names as defined in {{RFC8995}}.
The Content-Type and Accept headers indicate the constrained voucher format that is defined in the present document.
Because the Pledge used this format in the PVR, the JRC must also use this format in the RVR.

~~~
  REQ: POST https://masa.stok.nl/.well-known/brski/requestvoucher
  Content-Type: application/voucher-cose+cbor
  Accept: application/voucher-cose+cbor
  Body: <signed_rvr>
~~~

The payload signed_rvr is shown as hexadecimal dump (with lf added):

INSERT_CODE_FROM_FILE examples/cose-examples/rvr.hex END

The representiation of signed_rvr in CBOR diagnostic format (with lf added) is:

INSERT_CODE_FROM_FILE examples/cose-examples/rvr.txt END


## COSE-signed Voucher from MASA

The resulting voucher is created by the MASA and returned to the Registrar:

~~~
  RES: 200 OK
  Content-Type: application/voucher-cose+cbor
  Body: <signed_voucher>
~~~

The Registrar then returns the voucher to the Pledge:

~~~
  RES: 2.04 Changed
  Content-Format: 836
  Body: <signed_voucher>
~~~

It is signed by the MASA's private key (see {{masapriv}}) and can be
verified by the Pledge using the MASA's public key that it stores.

Below is the binary signed_voucher, encoded in hexadecimal (with lf added):

INSERT_CODE_FROM_FILE examples/cose-examples/voucher.hex END

The representiation of signed_voucher in CBOR diagnostic format (with lf added) is:

INSERT_CODE_FROM_FILE examples/cose-examples/voucher.txt END

In the above, the third element in the array is the plain CBOR voucher encoded as a CBOR byte string. 
When decoded, it can be represented by the following CBOR diagnostic notation:

INSERT_CODE_FROM_FILE examples/cose-examples/voucher-nonsigned.txt END

The largest element in the voucher is identified by key 8, which decodes to SID key 2459 (pinned-domain-cert).
It contains the complete DER-encoded X.509 certificate of the Registrar's domain CA. This certificate is 
shown in {{cose-example-domain-ca-cert}}.

# Generating Certificates with OpenSSL {#appendix-gencerts}

This informative appendix shows example Bash shell scripts to generate test certificates for the Pledge IDevID, the Registrar and the MASA.
The shell scripts cannot be run stand-alone because they depend on input files which are not all included in this appendix. Nevertheless,
these scripts may provide guidance on how OpenSSL can be configured for generating Constrained BRSKI certificates.

The scripts were tested with OpenSSL 3.0.2. Older versions may not work -- OpenSSL 1.1.1 for example does not support all extensions used.

INSERT_CODE_FROM_FILE examples/script-cose-examples/create-cert-Pledge.sh END
INSERT_CODE_FROM_FILE examples/script-cose-examples/x509v3.ext END
INSERT_CODE_FROM_FILE examples/script-cose-examples/create-cert-Registrar.sh END
INSERT_CODE_FROM_FILE examples/script-cose-examples/create-cert-MASA.sh END


# Pledge Device Class Profiles {#appendix-pledge-profiles}

This specification allows implementers to select between various functional options for the Pledge,
yielding different code size footprints and different requirements on Pledge hardware.
Thus for each product an optimal trade-off between functionality, development/maintenance cost and hardware cost can be made.

This appendix illustrates different selection outcomes by means of defining different example "profiles" of constrained Pledges. In the following
subsections, these profiles are defined and a comparison is provided.

## Minimal Pledge
The Minimal Pledge profile (Min) aims to reduce code size and hardware cost to a minimum. This comes with some severe functional restrictions, in particular:

* No support for EST re-enrollment: whenever this would be needed, a factory reset followed by a new bootstrap process is required.
* No support for change of Registrar: for this case, a factory reset followed by a new bootstrap process is required.

This profile would be appropriate for single-use devices which must be replaced rather than re-deployed.
That might  include medical devices, but also sensors used during construction, such as concrete temperature  sensors.

## Typical Pledge
The Typical Pledge profile (Typ) aims to support a typical Constrained BRSKI feature set including EST re-enrollment support and Registrar changes.

## Full-featured Pledge
The Full-featured Pledge profile (Full) illustrates a Pledge category that supports multiple bootstrap methods, hardware real-time clock, BRSKI/EST resource discovery, and
CSR Attributes request/response. It also supports most of the optional features defined in this specification.

## Comparison Chart of Pledge Classes
The below table specifies the functions implemented in the three example Pledge classes Min, Typ and Full.

|Function \|====================\| Profiles -> |Min|Typ|Full
|-|:-:|:-:|:-:
|**General** |===|===|====
|Support Constrained BRSKI bootstrap| Y | Y | Y
|Support other bootstrap method(s)| - | - | Y
|Real-time clock and cert time checks| - | - | Y
|**Constrained BRSKI** |===|===|====
|Discovery for rt=brski* | - | - | Y
|Support pinned Registrar public key (RPK) | Y | - | Y
|Support pinned Registrar certificate | - | Y | Y
|Support pinned Domain CA | - | Y | Y
|**Constrained EST**|===|===|====
|Discovery for rt=ace.est* | - | - | Y
|GET /att and response parsing | - | - | Y
|GET /crts format 281 (multiple CA certs) | - | - | Y
|GET /crts only format 287 (one CA cert only) | Y | Y | -
|ETag handling support for GET /crts | - | Y | Y
|Re-enrollment supported | - (1) | Y | Y
|6.6.1 optimized procedure | Y | Y | -
|Pro-active cert re-enrollment at own initiative | N/A | - | Y
|Periodic trust anchor retrieval GET /crts | - (1) | Y | Y
|Supports change of Registrar identity | - (1) | Y | Y

Notes: (1) is possible only by doing a factory-reset followed by a new bootstrap procedure.


